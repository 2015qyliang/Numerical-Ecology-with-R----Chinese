<font face="微软雅黑">

---

# **第五章: 非约束性排序 -- Unconstrained Ordination**

---

本章内容简介: 

- 5.1 目的
- 5.2 排序方法简介
- 5.3 主成分分析 - Principal Component Analysis (PCA)
- 5.4 对应分析 - Correspondence Analysis (CA)
- 5.5 主坐标分析 - Principal Coordinate Analysis (PCoA)
- 5.6 非度量多维尺度分析 - Nonmetric Multidimensional Scaling (NMDS)
- 5.7 手写 PCA 排序函数

---

## 5.1 目的

聚类分析查找数据集中的**不连续性**, 排序分析以连续轴的形式**提取主要趋势**. **排序方法**适用于对**自然生态群落数据集**(结构呈现**梯度**形式)进行分析. 

- 正确选择排序方法, 对排序结果进行解读
- 应用排序方法分析河流数据集和甲螨数据集
- 排序结果叠加聚类分析的结果并加以解释
- 使用外部数据集中的环境变量解释物种数据集排序分析的结构
- 编写 PCA 函数

---

## 5.2 排序方法简介

### 5.2.1 多维度空间 - Multidimensional Space

多变量数据集可被视为位于空间中的位点集合, 其中每个变量定义一个维度. 
通过位点的散点图揭示数据的结构. 
由于生态数据通常包含两个以上的变量, 因此绘制所有可能变量关系对的散点图十分繁琐 且所含信息量不大. (所有可能变量关系对的数量 -- 数学中的**组合** -- n*(n-1)/2 )

排序方法的目的是沿着减少数量的正交轴表示数据, 即它们以递减的顺序表示数据变化的主要趋势, 可以通过可视化关联解释分析结果. 本章介绍的所有排序分析方法都是**描述性**的, 没有提供统计检验来评估结果的显著性. 
第六章所介绍的**约束性排序**将提供**统计检验**方法. 

### 5.2.2 降维排序 - Ordination in Reduced Space

大多数排序方法(除 **NMDS** 之外)都是基于提取相关性矩阵中的特征值进行后续的分析. 
根据位点间的相异度差别以及变量类别进行分类. 

排序分析中的基本原则如下: *n* 个对象 & *p* 个变量; 在 *p*-维空间中, *n* 个对象可以表示为一个点簇(聚类), 该聚类结果并非圆形, 而是偏平的椭圆形(在一些维度上被拉伸, 在另一些维度上被压平); 经过变化的方向不一定与多维空间的单个维度（单个变量）对齐. **簇最长的方向对应于簇的最大方差的方向**. 
最大方差的方向对应于数据中存在的最强梯度: 这是最重要信息所在的位置. 要提取的下一个轴在方差中是第二重要的, 只要它与第一个轴正交(线性无关, 标量积为0). 
该过程继续, 直到计算出所有轴. 

当数据中存在一些主要结构(梯度或组)并且该方法在提取时是有效的, 那么第一轴包含大部分有用信息(提取了数据的大部分**方差**). 
在这种情况下, (降维空间)缩小空间(最常见的是二维)**投影**中**位点**之间的距离与多维空间中的对象之间的距离相对类似. 
*即使第一轴占方差的一小部分, 排序也很有用.* 
当在其他噪声数据集中存在一些有趣的结构时, 这可能发生 *第一轴占方差的一小部分* 这种情况. **==>>** **应该保留和解释多少轴? 有多少轴代表可解释的结构?** ==>> **取决于 方法和数据** -- 视具体情况而定 

本章介绍的方法如下:

- Principal component analysis (PCA): 主成分分析 -- 基于特征向量的方法, 对**原始定量数据**进行分析; scaling 1 -- 保留位点之间的 Euclidean 距离, scaling 2 -- 保留位点之间的 Mahalanobis 距离. 
- Correspondence analysis (CA): 对应分析 -- 所处理的数据必须是**非负+维度均质化+频率或者类频率**类型的数据; scaling 1 -- 行方向保留 χ2 (卡方) 距离, scaling 2 -- 列方向保留 χ2 (卡方) 距离. 在生态学中, 几乎可以完全应用于**群落组成型数据**分析. 
- Multiple correspondence analysis (MCA): 多元对应分析 -- 类别变量列表的排序, 所有的变量因子化.  
- Principal coordinate analysis (PCoA): 主坐标分析 -- Q 模式下, 对相异矩阵进行排序分析, 并不是对逐个变量表进行分析; 关联方法的选择上具有更高的灵活性. 
- Nonmetric multidimensional scaling (NMDS): 非度量多维尺度分析 -- 与上述几种方法不同, 不依赖于特征向量. 沿预定数量的轴表示对象集合, 同时保留它们之间的排序关系. 对相异性矩阵进行运算. 

PCoA & NMDS 可对任何 *平方相异性矩阵* 进行排序. 

---

## 5.3 主成分分析 - Principal Component Analysis (PCA)

### 5.3.1 主成分分析简介 (PCA)

多元正态分布矩阵(每个变量都是正态分布的). 

第一主轴(或主分量轴)是穿过该多元正态分布的浓度椭球的最大维度的直线(拥有方差的最大部分); 其余的轴线彼此正交并且相继较短. *(椭圆体, 轴线有长有短)* 
对于含有 *p* 个变量的矩阵最多含有 *p* 个主成分. 

PCA 对由变量所定义的原始轴系统进行旋转, 使得连续的新轴(主成分)相互正交, 且所获得的连续新轴(主成分)对应着 *散点* 最大方差的连续维度. 
主成分给出了新坐标系统中对象的位置. 

主成分分析的输入数据为 **方差矩阵** (比如包含维度均质化变量的方差和协方差的关联矩阵, 或者由维度异质性变量计算而来的相关性矩阵). 
PCA专门用于定量变量数据的分析. 
相异性矩阵 -- Euclidean 距离计算, 变量之间线性相关关系. 
不适用与 **原始物种丰度数据** 的分析. 
但可以对 **原始物种丰度数据** 进行 **数据预转换** 处理之后再进行主成分分析. 

PCA的排序结果仍遵循笛卡尔坐标系系统(Cartesian coordinate), 对象 -- 点, 变量 -- 箭头. 

vegan -- rda(); ade4 -- dudi.pca(); stats -- prcomp(); 本书中的自备函数 PCA.newr()

### 5.3.2 使用 rda() 对河流数据集的环境变量进行主成分分析 

对河流数据集中的 11 个定量环境变量进行分析, 分析不同环境变量之间的关联性如何以及从位点的排序分析中可以获得哪些信息. 

由于不同的环境变量采用了不同的测量标度(维度异质性), 因此需要首先获得相关性矩阵(标准化变量的协方差), 然后在进行主成分分析. 

#### 5.3.2.1 数据的预处理 

```{r}
# 解决警告信息的显示问题
# Warning: Input string not available in this locale
Sys.setlocale('LC_ALL','C')

# 导入分析包
# ade4 https://www.rdocumentation.org/packages/ade4/versions/1.7-13
# 生态型数据分析(多变量数据分析): 环境科学中的探索分析和 Euclidean 方法
# vegan https://www.rdocumentation.org/packages/vegan/versions/2.4-2
# 群落生态分析包: 排序方法, 多样性分析等
# gclus https://www.rdocumentation.org/packages/gclus/versions/1.3.2
# 聚类图形: 排序面板信息等
# ape https://www.rdocumentation.org/packages/ape/versions/5.3
# 系统发育与进化分析
# missMDA https://www.rdocumentation.org/packages/missMDA/versions/1.14
# 处理多变量数据分析处理缺失值
# FactoMineR https://www.rdocumentation.org/packages/FactoMineR/versions/1.41
# 多变量探索性分析和数据挖掘
library(ade4)
library(vegan) # 后期会重点解读该包的总和使用
library(gclus)
library(ape)
library(missMDA)
library(FactoMineR)

# 导入分析脚本和数据集
source("Functions/cleanplot.pca.R")
source("Functions/PCA.newr.R")
source("Functions/CA.newr.R")
load("Data/mite.RData")
load("Data/Doubs.RData")
# 移除第八列数据, 列名代表位点
spe <- spe[-8, ]
env <- env[-8, ]
spa <- spa[-8, ]
```

#### 5.3.2.2 相关性矩阵的主成分分析 (PCA) 

```{r}
summary(env)
# 结果中的 Inertia -- 变量数量 | 惯性, 惯量
# 1> 协方差矩阵的PCA分析结果中变量总方差 2> 相关性矩阵的PCA分析结果中对角线的数值和 = 变量自相关系数的总和 = 变量的数量
# 结果中的 Unconstrained -- PCA - 非约束性排序
# 结果中的 Eigenvalues -- 特征值 - PCA轴的重要性(方差)的度量 -可以表示为比例解释, 或轴的变化比例, 通过将每个特征值除以"总惯量"
(env.pca <- rda(env, # 环境变量数据
                scale = TRUE)) #对变量进行标准化
# Scaling -- 不要与 变量标准化 中的 "scale" 相混淆; 这里特指 排序结果投影到降维空间的图形展示方式; 
# 最优化展示 对象和变量 没有简单的方法
# 默认 scaling = 2 -- correlation biplot -- 相关性双序图; 特征向量被标准化为特征值的平方根; 
# 1> 双序图中 对象之间的距离 不近似于 多维孔空间中的 欧式距离, 2> 向量之间的角度反映相关性
# 物种得分: 变量箭头的坐标. "物种" 源于 分析包 vegan 使用的历史因素 
# 位点得分: 排序结果中位点的坐标. 对象 通常被称为 位点 
summary(env.pca) 
# distance biplot -- 距离双序图: 特征向量被标准化为单位向量; 
# 1> 双序图中 对象之间的距离 近似于 多维孔空间中的 欧式距离, 2> 向量之间的角度不反映之间的相关性
summary(env.pca, scaling = 1) 
summary(env.pca, scaling = 1, axes = 0) # 不查看物种得分和位点得分
```

> 如果解释**对象**之间的相互关系 ==>> scaling = 1 ; 如果解释**变量**之间的相互关系 ==>> scaling = 2

- scaling = 3 -- 折中标度 - 对称标度 -- 通过特征值的平方根来缩放位点和物种得分; 这种方案没有明确的解释规则, 不在本书中讨论

#### 5.3.2.3 对 vegan 分析包的输出结果进行信息提取,解释和可视化 

**排序轴** 数量的选择 -- 可解释 & 有意义

PCA -- 不是统计检验分析, 但是一种 **启发式分析** - 在降维空间空间中展示数据的主要特征; 通常, 应先检验特征值, 然后确定展示的轴(主成分)的数量. 轴数量的选择比较随意, 解释大于 75% 的方差, 或者依据其他的判断标准. 
比如, 计算断棒模型(broken stick model) -- 它将单位长度的一根棍子随机分成与PCA特征值相同数量的碎片; 断棒模型的理论方程已知; 然后将这些片段按长度递减的顺序排列, 并与特征值进行比较; 只解释特征值大于棍子相应部分长度的轴. 

```{r}
# ?cca.object # 约束排序的结果
(ev <- env.pca$CA$eig) # 查看特征值 - Eigenvalues

# 绘制与主成分数量的差异 
# https://www.rdocumentation.org/packages/stats/versions/3.6.0/topics/screeplot 
screeplot(env.pca, bstick = TRUE, npcs = length(env.pca$CA$eig))

# 绘制双序图
# http://biol09.biol.umontreal.ca/PLcourses/Ordination_section_1.1_PCA_Eng.pdf
# Scaling type 1: distance biplot
# Scaling type 2: correlation biplot,
biplot(env.pca, 
       scaling = 1, 
       main = "PCA - scaling 1")
biplot(env.pca, 
       main = "PCA - scaling 2")

# 需要矩形窗口来进行绘制
# par(mfrow = c(1, 2))
cleanplot.pca(env.pca, 
              scaling = 1, 
              mar.percent = 0.08)
cleanplot.pca(env.pca, 
              scaling = 2, 
              mar.percent = 0.04)

# 绘制带变量子集的图: ele, oxy, har, bod
# par(mfrow = c(1, 2))
var.subset <- c(2, 6, 10, 11)
cleanplot.pca(
  env.pca,
  scaling = 1, # scaling = "sites" for scaling 1
  select.spe = var.subset,
  mar.percent = 0.10
  )
cleanplot.pca(
  env.pca,
  scaling = 2, # scaling = "species" for scaling 2
  select.spe = var.subset,
  mar.percent = 0.04
  )

# 使用 biplot() 绘制变量的子集: ele, oxy, har, bod, 
# 圆圈 -- 平衡贡献圆
# 半径 --  sqrt(d/p)
# d -- number of axes represented in the biplot (usually d = 2)
# p -- number of dimensions of the PCA space (usually the number of variables of the data matrix)
# scaling = 1 有 -- Euclidean space
# scaling = 2 无 -- Mahalanobis space
# 箭头趋于正交(垂直), 相关性趋于 0 (scaling = 2)
# par(mfrow = c(1, 2))
# scores() https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/scores
# 从排序结果中获取物种或者位点的分数
var.sc1.sub <- scores(env.pca, 
                      scaling = 1, 
                      display = "species")[c(2, 6, 10, 11), ]
biplot(env.pca,
       scaling = 1,
       main = "PCA scaling 1",
       type = "n") 
text(env.pca,
     scaling = 1,
     display = "sites",
     cex = 0.7) 
arrows(
  0, # 起点
  0, # 起点
  var.sc1.sub[, 1], # 终点
  var.sc1.sub[, 2], # 终点
  length = 0.10,
  angle = 10,
  col = "red")
text(
  var.sc1.sub[, 1],
  var.sc1.sub[, 2],
  labels = rownames(var.sc1.sub),
  col = "red",
  pos = 4) # 下左上右 - 1,2,3,4

# scores() https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/scores
# 从排序结果中获取物种或者位点的分数
var.sc2.sub <- scores(env.pca, 
                      display = "species")[c(2, 6, 10, 11), ]
biplot(env.pca, 
       type = "n", 
       main = "PCA scaling 2")
text(env.pca,
     scaling = 2,
     display = "sites",
     cex = 0.7)
arrows(
  0,
  0,
  var.sc2.sub[, 1],
  var.sc2.sub[, 2],
  length = 0.10,
  angle = 10,
  col = "red"
  )
text(
  var.sc2.sub[, 1],
  var.sc2.sub[, 2],
  labels = rownames(var.sc2.sub),
  col = "red",
  pos = 4 # 下左上右 - 1,2,3,4
  )
```

```{r}
# 也可使用 分析包 BiodiversityR 中的 PCAsignificance() 函数展示 "broken stick model" 的结果
library(BiodiversityR)
PCAsignificance(env.pca)
# https://www.rdocumentation.org/packages/vegan/versions/2.3-5/topics/ordiplot
plot1 <- ordiplot(env.pca, choices=c(1,2), scaling=1)
ordiequilibriumcircle(env.pca, plot1)
```

#### 5.3.2.4 将补充**向量**投影到 PCA 的双序图(Biplot)

使用 predict() 函数将补充向量添加到 PCA 结果中(**预测新向量在 PCA 结果中的位置**). 
该函数使用排序结果计算新向量的排序得分. 
含有补充向量的数据框中必须具有原始数据集中相同的 *行名*. 

**分析包 vegan 中的 predict() 函数**

```{r}
# 剔除两个环境变量的的信息
env.pca2 <- rda(env[, -c(10, 11)], 
                scale = TRUE # 进行分析之前应将变量缩放 | 数据变换
                )
new.var <- env[, c(10, 11)]
# 计算新变量箭头的位置? (arrow tips)
new.vscores <- predict(env.pca2, # 模型预测
                       type = "sp",
                       newdata = new.var,
                       scaling = 2) # ??
biplot(env.pca2, scaling = 1)
arrows(
  0,
  0,
  new.vscores[, 1],
  new.vscores[, 2],
  length = 0.05,
  angle = 30,
  col = "blue"
  )
text(
  new.vscores[, 1],
  new.vscores[, 2],
  labels = rownames(new.vscores),
  cex = 0.8,
  col = "blue",
  pos = 2 # 下左上右 - 1,2,3,4
  )

biplot(env.pca2, scaling = 2)
arrows(
  0,
  0,
  new.vscores[, 1],
  new.vscores[, 2],
  length = 0.05,
  angle = 30,
  col = "blue"
  )
text(
  new.vscores[, 1],
  new.vscores[, 2],
  labels = rownames(new.vscores),
  cex = 0.8,
  col = "blue",
  pos = 2 # 下左上右 - 1,2,3,4
  )
```

> 补充向量在进行 predict() 分析之前的数据处理, 必须与原始数据集的处理过程相一致. 

#### 5.3.2.5 将补充**对象**投影到 PCA 的双序图(Biplot)

使用 predict() 函数将补充**对象**添加到 PCA 结果中(**预测新对象在 PCA 结果中的位置**).

**分析包 stats 中的 predict() 函数**

```{r}
# 使用 prcomp() 计算 PCA
# https://www.rdocumentation.org/packages/stats/versions/3.6.0/topics/prcomp
env.prcomp <- prcomp(env[-c(2, 8, 22), ], # 环境变量矩阵
                     scale. = TRUE # 进行分析之前应将变量缩放 | 数据变换
                     )

# 使用 biplot.prcomp() 可视化
# biplot(env.prcomp, scale = 0)
# 使用 plot() 绘制 PCA 位点分数
plot(
  env.prcomp$x[ ,1], 
  env.prcomp$x[ ,2], 
  type = "n", # 不立即绘制图形
  main = "PCA scaling 1 - sites with supplementary objects",
  xlab = "PCA 1",
  ylab = "PCA 2"
  )
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
text(
  env.prcomp$x[ ,1],
  env.prcomp$x[ ,2], 
  labels = rownames(env[-c(2, 8, 22), ])
  )

# 预测新的位点分数
new.sit <- env[c(2, 8, 22), ]
pca.newsit <- predict(env.prcomp, 
                      new.sit) 
# 将位点得分映射到 PCA 绘图中 
text(
   pca.newsit[, 1],
   pca.newsit[, 2],
   labels = rownames(pca.newsit),
   cex = 0.8,
   col = "blue"
   )
```

- **非本书中的示例** >>>

```{r}
# 使用 vegan 分析包中的 rda() 计算 PCA
env.small <- env[-c(2, 8, 22), ]
env.pca3 <- rda(env.small, 
                scale = TRUE) # 进行分析之前应将变量缩放 | 数据变换
new.sit <- env[c(2, 8, 22), ]
# 计算位点得分
# 提取相关的矩阵结果
U.mat <- env.pca3$CA$v
# 处理数据
env.mean <- apply(env.small, # 输入数据
                  2, # 列方向
                  mean) # 均值计算
env.sd <- apply(env.small, 
                2, # 列方向
                sd) # 标准差计算
# scale https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 矩阵对象的列进行缩放与居中
newsit.stand <- scale(new.sit, 
                      center = env.mean, 
                      scale = env.sd) 
# Raw scaling 1 scores of new sites
(newsit.scores <- newsit.stand %*% U.mat)
# 提取 vegan 结果对象中的位点分数
# scores() https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/scores
# 从排序结果中获取物种或者位点的分数
env.scores1 <- scores(
  env.pca,
  display = "sites",
  choices = c(1, 2),
  scaling = 1
  )
const <- attributes(env.scores1)$const # 获取对象属性列表
# 计算位点得分
(newsit.scores.cons <- newsit.scores / const)

biplot(env.pca3, 
       scaling = 1) # distance biplot
text(
  newsit.scores.cons[, 1],
  newsit.scores.cons[, 2],
  labels = rownames(newsit.scores.cons),
  cex = 0.8,
  col = "blue"
  )

# 手动计算 vegan 常量 (constant)
n <- nrow(env[-c(2, 8, 22), ])
eigenv <- env.pca3$CA$eig
tot <- sum(eigenv)
(const <- ((n - 1) * tot) ^ 0.25)
```

- <<< **上述示例非本书**

#### 5.3.2.6 比较聚类和排序的结果 

比较聚类分析结果和排序分析结果可助于确定位点分组中的差异. 
有两种方式可用于整合聚类分析结果和排序分析结果: 1> 排序结果中使用不同的颜色区分位点的簇, 2> 在原有图形展示的基础上叠加 **树形图**. 

```{r}
# 使用环境数据集聚类分析: 标准化变量之后计算 Euclidean 距离, 然后进行 ward 最小方差聚类分析
env.w <- hclust(dist(scale(env)), "ward.D")
# 将树形图切分成 4 组
gr <- cutree(env.w, k = 4)
(grl <- levels(factor(gr))) # 注意观察结果的呈现形式, 与 factor(gr) 进行对比
factor(gr)

# 提取位点信息, scaling 1
sit.sc1 <- scores(env.pca, 
                  display = "wa", 
                  scaling = 1)

# 使用类群标识符和颜色绘制 (scaling 1)
p <- plot(
  env.pca,
  display = "wa",
  scaling = 1,
  type = "n",
  main = "PCA correlation + clusters"
)
abline(v = 0, lty = "dotted")
abline(h = 0, lty = "dotted")
for (i in 1:length(grl)) {
  points(sit.sc1[gr == i, ],
         pch = (14 + i),
         cex = 2,
         col = i + 1)
  }
text(sit.sc1, 
     row.names(env), 
     cex = 0.7, 
     pos = 3) # 上左下右 - 1,2,3,4
# ordicluster 添加树形图
# https://github.com/vegandevs/vegan/blob/master/R/ordicluster.R
ordicluster(p, 
            env.w, 
            col = "dark grey")
```

### 5.3.3 已转换的物种数据的主成分分析(PCA) 

作为一种 **线性分析方法** 的 PCA 保留了位点之间的 Euclidean 距离, 因此不适用对 **物种丰度数据** 之间进行分析. 
物种丰度数据经过 **转换预处理** 之后可以进行后续相应的 PCA 分析. 

#### 5.3.3.1 对已 Hellinger-转换的鱼类物种数据进行主成分分析(PCA)

```{r}
# 物种数据进行 Hellinger 预转化 
spe.h <- decostand(spe, "hellinger") # 群落类型数据的标准化
(spe.h.pca <- rda(spe.h))

# 绘制与主成分数量的差异 
# 碎石图和破碎棒模型 
screeplot(spe.h.pca,
  bstick = TRUE, 
  npcs = length(spe.h.pca$CA$eig)
  )

# PCA biplots 双序图
(spe.pca.sc1 <- scores(spe.h.pca, 
                      display = "species", 
                      scaling = 1) ) # 注意参数 scaling ?????
(spe.pca.sc2 <- scores(spe.h.pca, 
                      display = "species", 
                      scaling = 2) ) # 注意参数 scaling ?????

# https://stackoverflow.com/questions/37128140/correlation-biplot-scaling-2-and-distance-biplot-scaling-1-pca-not-in-the-ri
# 绘制 triplot 三序图 ?
# par(mfrow = c(1, 2))
cleanplot.pca(spe.h.pca, 
              scaling = 1, # distance | 群落结构 - 簇 - 距离的远近 - 梯度结构
              mar.percent = 0.06)
cleanplot.pca(spe.h.pca, 
              scaling = 2, # correlationship
              mar.percent = 0.06)
```

- 技术提示: chi-square transformation 可以用于对物种数据的前处理

> 比较分析与 **无数据转换处理的原始数据** 的 PCA 分析结果的差异

```{r}
(spe.pca <- rda(spe))

# 绘制与主成分数量的差异 
# 碎石图和破碎棒模型 
screeplot(spe.pca,
  bstick = TRUE, 
  npcs = length(spe.pca$CA$eig)
  )

# PCA biplots 双序图
(spe.pca.sc1 <- scores(spe.pca, 
                      display = "species", 
                      scaling = 1) ) # 注意参数 scaling ?????
(spe.pca.sc2 <- scores(spe.pca, 
                      display = "species", 
                      scaling = 2) ) # 注意参数 scaling ?????

# https://stackoverflow.com/questions/37128140/correlation-biplot-scaling-2-and-distance-biplot-scaling-1-pca-not-in-the-ri
# 绘制 triplot 三序图 ?
# par(mfrow = c(1, 2))
cleanplot.pca(spe.pca, 
              scaling = 1, # distance
              mar.percent = 0.06)
cleanplot.pca(spe.pca, 
              scaling = 2, # correlationship
              mar.percent = 0.06)
```

#### 5.3.3.2 使用环境变量对轴进行事后解释(Passive -'post hoc'- Explanation)

```{r}
biplot(spe.h.pca, # 默认 scaling 2 | correlationship
       main = "PCA fish abundances - scaling 2")
# envfit() https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/envfit
# 将环境变量或因子拟合到排序结果上
# envfit() 寻找 环境变量中的向量或者因子平均值
# ? 点向量的投影与相应的环境变量具有最大的相关性, 这些因子表示因子水平的平均值 
# envfit() 对 环境变量 进行 置换检验, 计算 变量的 p-value
(spe.h.pca.env <- envfit(spe.h.pca, 
                         env, 
                         scaling = 1)) # ??
(spe.h.pca.env <- envfit(spe.h.pca, 
                         env, 
                         scaling = 2)) # ??
# 重点突出 - 显著性的变量
plot(spe.h.pca.env, # scaling = 2 的处理结果
     p.max = 0.05, 
     col = 3) # 添加显著性的环境变量
```

> 最佳方法 - 检验解释变量 - **响应变量列表** ? *第六章有所涉及*

### 5.3.4 主成分分析(PCA)的主要应用

PCA 也有很多使用限制, 比如对偏多项分布不敏感. 
PCA 运算的主要步骤是 **对方差矩阵(线性协方差或者相关性)进行奇异值分解 (eigen-decomposition)**, 协方差务必由 **定量数据** 计算而来. 

- 输入数据类型必须是 **维度均质化的变量表** -- 变量方差和 需要分解成 特征值; 只有度量相一致的变量 产生的 方差才有意义(方差的单位 -- 变量单位的平方), 数据转换处理之后的变量没有 *量纲* (dimensionless). 
- 不能用于计算 **转置数据矩阵** -- 对象之间的协方差或者相关性 无意义
- 协方差 和 相关性 由定量变量确定 -- PCA对数据精度的变化具有很强的鲁棒性 
- 二元数据(有无)可应用 PCA
- 对 物种有无数据 进行 PCA 之间, 需要进行数据变换(chord, Hellinger or log-chord transformation)
- 避免错误地解释变量之间的关系 -- 根据向量箭头的顶部(尖端)的近似值, 而不是它们在双序图中的角度. 

### 5.3.5 使用 PCA.newr() 进行主成分分析(PCA)

本书提供了 *快速分析脚本 -- PCA.newr() 和 biplot.PCA.newr()*

```{r}
# 使用 PCA.newr() 和 biplot.PCA.newr() 对环境数据集进行主成分分析(PCA)
# 其中, PCA 相关函数默认使用 scaling 1 -- distance biplot
# Scaling 2 - correlation biplot
(env.PCA.PL <- PCA.newr(env, stand = TRUE))
biplot.PCA.newr(env.PCA.PL)
biplot.PCA.newr(env.PCA.PL, 
                scaling = 2) # scaling 2 -- correlation biplot
```

### 5.3.6 主成分分析中的缺省值处理 

PCA 无法对 非完整数据矩阵 进行计算. 
**缺失值 - 估计 - 替换填充** 
PCA - 迭代计算 - 复杂运算可以避免 *过拟合* 和 *方差估计不足* 等问题. 

```{r}
# 使用 NA 替换缺省值 
env.miss3 <- env
env.miss3[2, 5] <- NA    # pH
env.miss3[18, 7] <- NA   # pho
env.miss3[22, 11] <- NA  # dbo

# 忽略缺省值重新
mean(env.miss3[, 5], na.rm = TRUE)
mean(env.miss3[, 7], na.rm = TRUE)
mean(env.miss3[, 11], na.rm = TRUE)

# https://www.rdocumentation.org/packages/missMDA/versions/1.14/topics/imputePCA
# 用主成分分析模型输入数据集的缺失值
(env.imp <- imputePCA(env.miss3))
env.imp$completeObs[2, 5]    # 初始值: 8.0
env.imp$completeObs[18, 7]   # 初始值: 0.60
env.imp$completeObs[22, 11]  # 初始值: 16.4

env.imp3 <- env.imp$completeObs
env.imp3.pca <- rda(env.imp3, 
                    scale = TRUE) # 进行分析之前应将变量缩放 | 数据变换

# Procrustes analysis
# https://en.wikipedia.org/wiki/Procrustes_analysis
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/procrustes
# 将配置旋转到与其他配置的最大相似性
(pca.proc <- procrustes(env.pca, 
                       env.imp3.pca, 
                       scaling = 1)) # scaling 1 -- distance biplot ??
# 通过可视化分析 真实数据 PCA 结果 与 推算数据 PCA 结果 的差异
plot(pca.proc, 
     main = "Procrustes rotation of original and imputed PCA\n3 missing values")
points(pca.proc, display = "target", col = "red")
text(
  pca.proc,
  display = "target",
  col = "red",
  pos = 4,
  cex = 0.6
  )

# 缺省值随机替换
rnd <- matrix(sample(c(rep(1, 32), rep(0, 287))), 29, 11)
env.miss32 <- env
env.miss32[rnd == 1] <- NA
# 统计每个变量的缺省值数量(位点方向)
summary(t(env.miss32))
# 统计的替代方法
sapply(as.data.frame(t(env.miss32)), function(x) sum(is.na(x)))

(env.imp2 <- imputePCA(env.miss32))
env.imp32 <- env.imp2$completeObs
env.imp32.pca <- rda(env.imp32, 
                     scale = TRUE) # 进行分析之前应将变量缩放 | 数据变换

# Procrustes analysis
# https://en.wikipedia.org/wiki/Procrustes_analysis
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/procrustes
# 将配置旋转到与其他配置的最大相似性
pca.proc32 <- procrustes(env.pca, 
                         env.imp32.pca, 
                         scaling = 1) # scaling 1 -- distance biplot ??
# 通过可视化分析 真实数据 PCA 结果 与 推算数据 PCA 结果 的差异
plot(pca.proc32, 
     main = "Procrustes rotation of original and imputed PCA\n32 missing values")
points(pca.proc32, display = "target", col = "red")
text(
  pca.proc32,
  display = "target",
  col = "red",
  pos = 4,
  cex = 0.6
  )

# 比较分析两种不同的主成分分析结果 scaling 2
# scaling 2 -- correlation biplot
# par(mfrow = c(1, 2))
biplot(env.pca, 
       main = "Original PCA, scaling 2")
biplot(env.imp32.pca, 
       main = "Imputed PCA, scaling 2")
```

---

## 5.4 对应分析(Correspondence Analysis, CA)

### 5.4.1 简介 

对应分析 -- 对口 物种有无数据集 和 物种丰度数据集. 
输入数据 -- 非负 + 维度均质化 + 频率 或者类频率 (物种计数, 生物质, 物种有无数据集), 对于物种丰度数据可以不用经过 数据转换 直接进行对应分析. 
CA 计算位点之间的 χ2 距离(卡方距离, 不受双零数据的影响, 非对称的距离函数), 而非 Euclidean 距离. 

原始数据转换 => Q 矩阵(描述 位点 对 Pearson χ2 统计的贡献值) => 奇异值分解(singular value decomposition) => 提取特征向量 & 特征值. 

技术原因 -- 由于Q矩阵计算中的频率的隐含中心, CA排序产生的一个轴小于min [n，p]. 
与在PCA中一样, 正交轴按其所代表的变化的降序排列, 但不是数据的总方差, 而是通过称为总惯性的量(矩阵Q中所有值的平方和). 
各个特征值总是小于1. 
要知道沿轴表示的变化量, 可以将该轴的特征值除以物种数据矩阵的总惯量. 

在对应分析的可视化图形中, 对象(位点 - 行) 和 物种(变量 - 列) 都是 **点 - 表示**. 

- CA scaling 1: 行(位点) 位于 列(物种)的质心 -- 对位点(行方向, 对象)的排序分析 非常适合. 多维空间中, 卡方距离(χ2) 保留了 对象之间的距离. 1> 降维空间中 对象的距离 与 卡方距离 相类似, 相互接近的对象点具有相类似的物种相对频率; 2> 物种点 周围的对象点 -- 对物种具有高贡献. 
- CA scaling 2: 列(物种) 位于 行(位点)的质心 -- 对物种(列方向, 变量)的排序分析 非常适合. 多维空间中, 卡方距离(χ2) 保留了 物种之间的距离. 1> 降维空间中 物种的距离 保留在 卡方距离 中, 相互接近的物种点在不同位点(对象)之间具有相类似的相对频率; 2> 对象(位点)点 周围的物种点 更有可能在同一个位点(对象)中 发现, 或者比 远处的物种点 在该对象(位点)点具有更高的频率. 

*scaling 的选择 影响 特征向量的绘制, 但不影响特征值*

### 5.4.2 使用 vegan 分析包的 cca() 函数进行对应分析(CA) 

#### 5.4.2.1 分析并绘制双序图(Biplots) 

```{r}
# 对原始物种丰度数据集进行对应分析(Correspondence Analysis, CA)
(spe.ca <- cca(spe))
summary(spe.ca)  # 默认 scaling 2
summary(spe.ca, 
        scaling = 1) 

# 绘制与主成分数量的差异
screeplot(spe.ca, 
          bstick = TRUE, # 注意与下图进行比较
          npcs = length(spe.ca$CA$eig))

screeplot(spe.ca, 
          bstick = FALSE, # 注意与上图进行比较
          npcs = length(spe.ca$CA$eig))

# 绘制对应分析(CA)的双序图 -- biplots
# par(mfrow = c(1, 2))
# Scaling 1: sites are centroids of species
plot(spe.ca, 
     scaling = 1, 
     main = "CA fish abundances - biplot scaling 1"
     )
# Scaling 2 (default): species are centroids of sites
plot(spe.ca, 
     main = "CA fish abundances - biplot scaling 2")
```

**对双序图的解释 -- 位点: 上游, 中游, 下游; 物种: 聚集在 ? 游分布较多或者较少...**

#### 5.4.2.2 使用对应分析双序图预测 Sulementar 位点或物种

将新增加的位点(对象, 行方向)信息和物种(变量, 列方向)信息投影到对应分析的双序图中, 即新增信息(对象或者变量在坐标系中的位置), 分析与原始数据的点(位点或者物种)之间的关系. 

使用分析包 stats 中的 predict() 函数. 

```{r}
# 预测对应分析中的补充物种 
spe.small <- spe[, -c(1, 3, 10)]  # 物种数据集进行删减
spesmall.ca <- cca(spe.small)
plot(spesmall.ca, 
     display = "species", 
     scaling = 2)
# 对 3 个不同的物种进行分析
newspe3 <- spe[, c(1, 3, 10)]
# 模型预测
ca.newspe <- predict(
                 spesmall.ca, 
                 newspe3, 
                 type = "sp", 
                 scaling = 2)
text(
  ca.newspe[, 1],
  ca.newspe[, 2],
  labels = rownames(ca.newspe),
  cex = 0.8,
  col = "blue"
  )
```

#### 5.4.2.3 环境变量的事后曲线拟合 

在 5.3.3.2 中使用 envfit() 函数将环境变量投影到了 PCA 双序图中; 
但是, 线性拟合和箭头的投影只能解释**线性的物种-环境关系**. 
有时, 会研究 **特定的环境变量** 在非线性的基础上如何与排序结果相关联. 
可以通过在排序图上拟合这些环境变量的表面来实现. 

使用 envfit() 函数作为第一步处理, 模型的拟合限制在两个变量之间; 
使用分析包 vegan 中的 ordisurf() 函数进行曲线拟合, 通过广义加法模型(generalized additive models, GAM)拟合平滑的二维曲线. 

```{r}
# 在对应分析的双序图中进行曲线拟合(Curve fitting) 
plot(spe.ca, 
     main = "CA fish abundances - scaling 2", 
     sub = "Fitted curves: discharge (red), ammonium (green)")
# envfit() https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/envfit
# 将环境变量或因子拟合到排序结果上
# envfit() 寻找 环境变量中的向量或者因子平均值
# ? 点向量的投影与相应的环境变量具有最大的相关性, 这些因子表示因子水平的平均值 
# envfit() 对 环境变量 进行 置换检验, 计算 变量的 p-value
spe.ca.env <- envfit(spe.ca ~ dis + amm, # 保留两个变量 
                     env) # 注意这种表示!!!
plot(spe.ca.env)
# 在排序结果上绘制拟合曲线
# ordisurf https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/ordisurf
ordisurf(spe.ca, 
         env$dis, 
         add = TRUE) # 添加轮廓 | 重新绘制 - False
ordisurf(spe.ca, 
         env$amm, 
         add = TRUE, 
         col = "green")
```

#### 5.4.2.4 在排序结果轴的基础上重新对数据表进行排序

对应分析的结果有时会根据第一排序轴对数据表进行重新排序. 
可以使用分析包 vegan 中的 vegemite() 函数比较重新排序表和原始表. 
还可以通过 tabasco() 函数将有序丰度表通过热图的形式进行展示. 

```{r}
# 对应分析之后的物种数据表 
# vegemite() 展示紧凑的群落表 
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/vegemite
vegemite(spe, spe.ca)

# 通过热图来展示对应分析排序的物种表
# 展示紧凑的群落表 - 热图形式
tabasco(spe, spe.ca)
```

### 5.4.3 使用 CA.newr() 进行对应分析(CA)

```{r}
# 使用 CA.newr() 进行对应分析(CA)
spe.CA.PL <- CA.newr(spe)

# par(mfrow = c(1, 2))
biplot.CA(spe.CA.PL, 
          scaling = 1, # scaling 1 -- distance biplot
          cex = 1)
biplot.CA(spe.CA.PL, 
          scaling = 2, # scaling 2 -- correlation biplot
          cex = 1)

# 按照对应分析结果的第一轴对数据表进行排序分析 
summary(spe.CA.PL)
# 数据结果转置
t(spe[order(as.vector(spe.CA.PL$scaling1$sites[, 1])), 
      order(as.vector(spe.CA.PL$scaling1$species[, 1]))])
# 物种的累积拟合 - Cumulative fit of species
spe.CA.PL$fit$cumulfit.spe
# 位点的累积拟合 - Cumulative fit of sites
spe.CA.PL$fit$cumulfit.obj
```

### 5.4.4 弓形效应与去趋势对应分析 -- Arch Effect and Detrended Correspondence Analysis (DCA)

长期的环境梯度通常支持一系列物种. 
由于受环境因素控制的物种往往具有**单峰分布**, 因此 长梯度 可能包含在梯度的两端没有共同物种的位点;  
因此, 它们的不相似性具有最大可能值(或它们的相似性为0). 
但是如果从梯度的任何一个点开始并慢慢走向终点, 那么连续的站点会比起始点越来越不同, 直到达到D的最大值. 
因此, 梯度表示为一对CA轴上的弓形, 而不是直线. 
下文将介绍几种**去趋势技术**来解决这种效应, 并使整理图中的梯度变直; 

- https://link.springer.com/article/10.1007/BF00048870
- https://en.wikipedia.org/wiki/Detrended_correspondence_analysis
- **https://mb3is.megx.net/gustame/indirect-gradient-analysis/detrended-correspondence-analysis**
- https://www.pisces-conservation.com/caphelp/index.html?decorana.html
- http://ecology.msu.montana.edu/labdsv/R/labs/lab10/lab10.html
- https://cran.r-project.org/web/packages/vegan/vignettes/intro-vegan.pdf
- http://cc.oulu.fi/~jarioksa/softhelp/vegan/html/decorana.html

去趋势对应分析(DCA): 

- **通过与非线性重新缩放相结合的段去趋势: **轴-1 被分成任意数量的段, 并且在每个段内, 沿 轴-2 的对象得分的平均值等于零. *任意选择的段数对结果有很大影响*. 文献中提出的 DCA 结果表明沿 *第二轴* 的分数基本上意味着更少. 强烈反对使用这种形式的 DCA 作为排序分析技术: 然而, 它可以用于估计 *第一排序轴* 的"辐射长度", 以物种周转的标准偏差单位表示. **梯度长度大于 4** 表示某些物种沿轴线具有单峰响应. 
- **通过多项式去除: **关于 *弓效应* 的起源的另一推理线 导致 观察到当发生弓时, 第二轴可以被视为与第一轴成二次方相关(第二轴是第一轴的二次幂), 这解释了点的散射的抛物线形状. 
因此, 一种解决方案是使第二轴不仅是 线性的, 而且与第一轴呈现 **二次独立**. 
虽然具有直观的吸引力, 但应谨慎应用这种去除趋势的方法, 因为它实际上对数据施加了约束模型(本章节所介绍的是**非约束性分析**). 

使用分析包 vegan 中的 decorana() 函数对数据进行 第一种方法的 DCA 分析, 输出结果中的 轴长度 叫作为 "Axis length". 

鉴于 DCA 分析中的种种问题, 本文不再讨论. 
即使有很长的生态梯度, 也可以通过使用 弦,Hellinger或对数-弦 变换物种数据的 PCA 获得有意义的排序. 

PCA 中存在同类的更极端的效果, 它被称为马蹄形效应 -- 因为在强梯度的情况下, 两端的位置向内弯曲并且看起来比其他对更近. 
这是因为 PCA 将 **双零** 视为相似性; 因此, 位于具有许多 **双零的生态梯度** 的相对端的位点在这方面彼此"相似". 
Hellinger  或 弦变换 的物种数据 可部分地缓解这个问题. 

### 5.4.5 多重对应分析(Multiple Correspondence Analysis, MCA)

多重对应分析(MCA)是与 PCA 的相对应的分析方法, 用于分类变量表的排序, 即数据框中的所有变量都是因子. 
它是一种特殊形式的对应分析, 其中变量是分类的(类别属性). 
它主要用于分析一系列个体(例如调查中的人,分类学研究中的标本), 其特征在于定性变量(例如, 答案选择的问题,或形态特征), 
如果通过定性变量描述场地, 多重对应分析(Multiple Correspondence Analysis, MCA)也可用于*环境研究* 

在多重对应分析(Multiple Correspondence Analysis, MCA)中, 数据的变化表示为惯性(inertia, 惯量) (和在对应分析中一样). 
在大多数实际情况中, 与 CA轴的惯性或 PCA轴的方差 相比, 前几个轴的惯性 相对较低, 因为 MCA 计算涉及数据矩阵的扩展, 因此所有 p 的水平 变量由 虚拟二进制变量 表示. 
这种矩阵称为 *完全析取表*. 
MCA 在通过分析包 MASS 中的 mca() 函数实现; 在分析包 FactoMineR 中的 MCA() 函数中亦可实现. 

#### 5.4.5.1 对甲螨数据集(Oribatid Mite Data Set)进行多重对应分析(MCA) 

添加两组补充变量: 
- 1> 两个定量环境变量基质密度和含水量; 
- 2> Hellinger 转化的 Oribatid 螨虫数据集的 4 组分类进行 Ward 最小方差层次聚类

```{r}
mite.h <- decostand(mite, "hel") # 进行数据变换
mite.h.ward <- hclust(dist(mite.h), "ward.D2") # 对距离矩阵进行 ward 最小方差聚类分析
mite.h.w.g <- cutree(mite.h.ward, 4) # 将聚类结果分成 4 份
mite.envplus <- data.frame(mite.env, mite.h.w.g) # 整合数据框信息

# 对定性环境数据 + 补充变量进行多重对应分析
# (1) quantitative environmental data 
# (2) 4-group mite classification 
# 默认进行绘图展示: graph=TRUE.
mite.env.MCA <- MCA(mite.envplus, 
                    quanti.sup = 1:2, 
                    quali.sup = 6)
```

> **重点在于对结果的解读**

```{r}
mite.env.MCA
# 展示列联表 - 变量 "Shrub" & "Topo"
table(mite.env$Shrub, mite.env$Topo)
```

---

## 5.5 主坐标分析(Principal Coordinate Analysis, PCoA)



### 5.5.1 简介




### 5.5.2 使用 vegan 分析包的 cmdscale() 函数对河流数据集进行主坐标分析(PCoA) 

```{r}
# 对鱼类物种数据集的百分差异相异矩阵进行主坐标分析(PCOA)
# vegdist() 对群落数据进行相异指数的计算
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/vegdist
spe.bray <- vegdist(spe) # 默认方法 - bray
spe.b.pcoa <- cmdscale(spe.bray, 
                       k = (nrow(spe) - 1), 
                       eig = TRUE)
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/ordiplot
# 绘制排序图
ordiplot(scores(spe.b.pcoa, choices = c(1, 2)),
         type = "t",
         main = "PCoA with species weighted averages")
abline(h = 0, 
       lty = 3) # 添加线
abline(v = 0, 
       lty = 3)
# 添加物种的加权平均预测值
spe.wa <- wascores(spe.b.pcoa$points[, 1:2], spe)
text(spe.wa, 
     rownames(spe.wa), 
     cex = 0.7, 
     col = "red")
# 对环境变量进行事后预测检验 - posteriori projection 
(spe.b.pcoa.env <- envfit(spe.b.pcoa, env))
# 绘制显著变量
plot(spe.b.pcoa.env, 
     p.max = 0.05, 
     col = 3)
```


### 5.5.3 使用 pcoa() 对河流数据集进行主坐标分析(PCoA) 

```{r}
# 使用 pcoa() 函数对物种向量进行主坐标分析和预测
spe.h.pcoa <- pcoa(dist(spe.h))
# par(mfrow = c(1, 2))
# 第一个双序图: Hellinger-transformed species data
biplot.pcoa(spe.h.pcoa, 
            spe.h, 
            dir.axis1 = -1)
abline(h = 0, lty = 3)
abline(v = 0, lty = 3)
text(-0.5, 
     0.45, 
     "a", 
     cex = 2)

# 第二个双序图: standardized Hellinger-transformed species data - 标准化
spe.std <- scale(spe.h)
biplot.pcoa(spe.h.pcoa, 
            spe.std, 
            dir.axis1 = -1)
abline(h = 0, 
       lty = 3)
abline(v = 0, 
       lty = 3)
text(-2.7, 
     2.45, "b", 
     cex = 2)

# 第三个双序图: standardized Hellinger-transformed species data;
# 只绘制 4 个物种

spe.std <- scale(spe.h)
biplot.pcoa(spe.h.pcoa, 
            spe.h[, c(2, 5, 11, 21)], 
            dir.axis1 = -1)
abline(h = 0, 
       lty = 3)
abline(v = 0, 
       lty = 3)



# 比较 欧式(Euclidean)和非欧式相异矩阵的主坐标分析(PCOA)结果
# PCoA on a Hellinger distance matrix

# https://www.rdocumentation.org/packages/ade4/versions/1.7-13/topics/is.euclid
is.euclid(dist(spe.h)) # 检查距离矩阵是否是欧式的 - Euclidean
summary(spe.h.pcoa)
spe.h.pcoa$values

# 对百分差异的相异矩阵进行主坐标分析(PCoA)
is.euclid(spe.bray)
spe.bray.pcoa <- pcoa(spe.bray)
spe.bray.pcoa$values # Observe eigenvalues 18 and following

# 对百分差异的相异矩阵的平方根进行主坐标分析(PCoA)
is.euclid(sqrt(spe.bray))
spe.braysq.pcoa <- pcoa(sqrt(spe.bray))
spe.braysq.pcoa$values	# 观察特征值 - eigenvalues

# PCoA on a percentage difference dissimilarity matrix with Lingoes correction
# 对百分差异的相异矩阵进行Lingoes校正-主坐标分析(PCoA)
spe.brayl.pcoa <- pcoa(spe.bray, 
                       correction = "lingoes")
spe.brayl.pcoa$values # 观察特征值(eigenvalues) & col. 1 & col. 2

# 对百分差异的相异矩阵进行cailliez校正-主坐标分析(PCoA)
spe.brayc.pcoa <- pcoa(spe.bray, 
                       correction = "cailliez")
spe.brayc.pcoa$values # 观察特征值(eigenvalues) & col. 1 & col. 2

```


---

## 5.6 非度量多维尺度分析(Nonmetric Multidimensional Scaling, NMDS)




### 5.6.1 简介




### 5.6.2 使用非度量多维尺度分析鱼类数据集

```{r}
# 对鱼类数据集的百分比差异相异矩阵进行非度量多维尺度分析(NMDS)
spe.nmds <- metaMDS(spe, 
                    distance = "bray")
spe.nmds
spe.nmds$stress

plot(
  spe.nmds,
  type = "t",
  main = paste(
    "NMDS/Percentage difference - Stress =",
    round(spe.nmds$stress, 3)
    )
  )

# par(mfrow = c(1, 2))
# stressplot() https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/stressplot.wcmdscale
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/goodness.metaMDS
stressplot(spe.nmds, 
           main = "Shepard plot")
gof <- goodness(spe.nmds)
plot(spe.nmds, 
     type = "t", 
     main = "Goodness of fit")
points(spe.nmds, 
       display = "sites", 
       cex = gof * 300)

# 对百分比相异矩阵进行 Ward 最小方差聚类分析, 并划分出 4 组
spe.bray.ward <- hclust(spe.bray, 
                        "ward.D") 
spe.bw.groups <- cutree(spe.bray.ward, 
                        k = 4)
grp.lev <- levels(factor(spe.bw.groups)) # 反馈因子的不同值 - 向量形式
# 结合汇总非度量多维尺度分析结果
sit.sc <- scores(spe.nmds) # 两列多行的'矩阵'类型
# 绘制排序结果图 - x-y 绘图
p <- ordiplot(sit.sc, 
              type = "n", 
              main = "NMDS/% difference + clusters Ward/% difference")
for (i in 1:length(grp.lev)) {
  points(sit.sc[spe.bw.groups == i, ],
         pch = (14 + i),
         cex = 2,
         col = i + 1)
  }
text(sit.sc, 
     row.names(spe), 
     pos = 4, 
     cex = 0.7)
# 添加树形图
ordicluster(p, 
            spe.bray.ward, 
            col = "dark grey")
```


### 5.6.3 如何选择主坐标分析与非度量多维尺度分析? PCoA or NMDS ?


---

## 5.7 手写主成分分析(PCA) 排序函数

```{r}
myPCA <- function(Y) {
  Y.mat <- as.matrix(Y)
  object.names <- rownames(Y)
  var.names <- colnames(Y)
  
  # 质心化数据 ? - Centre the data (needed to compute matrix F)
  Y.cent <- scale(Y.mat, 
                  center = TRUE, 
                  scale = FALSE) # 是否对数据进行缩放 | F - 否
  
  # 计算协方差 - 矩阵 S
  Y.cov <- cov(Y.cent)
  
  # 特征向量 & 特征值 - Eigenvectors and eigenvalues of S (eq. 9.1 & 9.2)
  Y.eig <- eigen(Y.cov)
  
  # 复制特征向量至矩阵 U (用于表征变量 - scaling 1 - biplots)
  U <- Y.eig$vectors
  rownames(U) <- var.names
  
  # 计算矩阵 F (用以表征对象 - scaling 1 - plots)
  F <- Y.cent %*% U  # eq. 9.4
  rownames(F) <- object.names
  
  # 计算矩阵 U2 (用以表征变量 - scaling 2 plots)
  U2 <- U %*% diag(Y.eig$values ^ 0.5)
  rownames(U2) <- var.names
  
  # 计算矩阵 G (用以表征对象 - scaling 2 plots)
  G <- F %*% diag(Y.eig$values ^ 0.5)
  rownames(G) <- object.names
  
  # 输出包含结果的所有列表
  result <- list(Y.eig$values, U, F, U2, G)
  names(result) <- c("eigenvalues", "U", "F", "U2", "G")
  result
}

# 使用手写 PCA-函数对鱼类物种数据集进行分析
fish.PCA <- myPCA(spe.h)
summary(fish.PCA)
# 特征值
fish.PCA$eigenvalues
# 特征值表示为百分比
(pv <-round(100 * fish.PCA$eigenvalues / sum(fish.PCA$eigenvalues), 
  2))
# 总方差(分母)的替代计算, 两位小数
round(100 * fish.PCA$eigenvalues / sum(diag(cov(spe.h))), 
      2)
# 将累积特征值表示为百分比, 两位小数
round(cumsum(100 * fish.PCA$eigenvalues / sum(fish.PCA$eigenvalues)), 
      2)

# 绘制双序图
# par(mfrow = c(1, 2))
# scaling 1 -- distance biplot
biplot(fish.PCA$F, fish.PCA$U)
# scaling 2 -- correlation biplot
biplot(fish.PCA$G, fish.PCA$U2)

# 使用基本函数 plot() 进行绘制
# par(mfrow = c(1, 2))
# scaling 1 -- distance biplot
plot(
  fish.PCA$F[, 1],
  fish.PCA$F[, 2],
  asp = 1,
  main = "PCA scaling 1",
  xlab = paste("Axis 1 (", pv[1], "%)", sep = ""),
  ylab = paste("Axis 2 (", pv[2], "%)", sep = "")
  )
# 绘制变量
arrows(
  x0 = 0,
  y0 = 0,
  fish.PCA$U[, 1],
  fish.PCA$U[, 2],
  length = 0.1,
  col = "red"
  )
# 添加对象
text(
  fish.PCA$F[, 1],
  fish.PCA$F[, 2],
  labels = row.names(spe),
  pos = 3,
  cex = 0.8
  )
# 添加变量名
text(
  fish.PCA$U[, 1],
  fish.PCA$U[, 2],
  labels = colnames(spe),
  adj = c(-0.2, 0.2),
  col = "red",
  cex = 0.8
  )
abline(h = 0, 
       lty = 3)
abline(v = 0, 
       lty = 3)

# scaling 2 -- correlation biplot
plot(
  fish.PCA$G[, 1],
  fish.PCA$G[, 2],
  asp = 1,
  main = "PCA scaling 2",
  xlab = paste("Axis 1 (", pv[1], "%)", sep = ""),
  ylab = paste("Axis 2 (", pv[2], "%)", sep = "")
  )
# 绘制变量
arrows(
  x0 = 0,
  y0 = 0,
  fish.PCA$U2[, 1],
  fish.PCA$U2[, 2],
  length = 0.1,
  col = "red"
  )
# 添加对象
text(
  fish.PCA$G[, 1],
  fish.PCA$G[, 2],
  labels = row.names(spe),
  pos = 3,
  cex = 0.8
  )
# 添加变量名
text(
  fish.PCA$U2[, 1],
  fish.PCA$U2[, 2],
  labels = colnames(spe),
  col = "red",
  adj = c(-0.2, 0.2),
  cex = 0.8
  )
abline(h = 0, lty = 3)
abline(v = 0, lty = 3)
```




---

</font>
