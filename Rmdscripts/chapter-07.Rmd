<font face="微软雅黑">

---

# **第七章：生态数据的空间分析**

---

本章内容简介：

- 7.1 目标
- 7.2 空间结构与空间分析简介
- 7.3 多变量趋势面分析(Multivariate Trend-Surface Analysis)
- 7.4 基于特征向量的空间变量与空间模型(Eigenvector-Based Spatial Variables and Spatial Modelling)
- 7.5 另一种空间结构的观察方法: 多尺度排序(Multiscale Ordination, MSO)
- 7.6 多元变量方差分析中的无重复时空交互检验(Space-Time Interaction Test in Multivariate ANOVA, Without Replicates)
- 7.7 结论

---

## 7.1 目标


---

## 7.2 空间结构与空间分析简介

### 7.2.1 简介

### 7.2.2 诱导空间依赖与空间自相关(Induced Spatial Dependence and Spatial Autocorrelation)

### 7.2.3 空间尺度(Spatial Scale)

### 7.2.4 空间异质性(Spatial Heterogeneity)

### 7.2.5 空间相关或相关函数与空间相关图(Spatial Correlation or Autocorrelation Functions and Spatial Correlograms)


```{r}
# 解决警告信息的显示问题
# Warning: Input string not available in this locale
Sys.setlocale('LC_ALL','C')

# 导入分析包
# ade4 https://www.rdocumentation.org/packages/ade4/versions/1.7-13
# 生态型数据分析(多变量数据分析): 环境科学中的探索分析和 Euclidean 方法
# vegan https://www.rdocumentation.org/packages/vegan/versions/2.4-2
# 群落生态分析包: 排序方法, 多样性分析等
# ape https://www.rdocumentation.org/packages/ape/versions/5.3
# 系统发育与进化分析
# adegraphics https://www.rdocumentation.org/packages/adegraphics/versions/1.0-15
# 表示多变量数据的图形功能,  'ade4' 的重新集成
# adespatial https://www.rdocumentation.org/packages/adespatial/versions/0.3-4
# 多元多尺度空间分析
# spdep 空间依赖性: 加权方案, 统计, 模型
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2
# adegraphics 用于表示多变量数据的图形功能, 它是'ade4'包中可用功能的完全重新实现
# https://www.rdocumentation.org/packages/adegraphics/versions/1.0-15
library(ape)
library(spdep)
library(ade4)
library(adegraphics)
library(adespatial)
library(vegan)

# 导入分析脚本 & 数据集
source("Functions/plot.links.R")
source("Functions/sr.value.R")
source("Functions/quickMEM.R")
source("Functions/scalog.R")
load("Data/mite.RData")

# 数据变换
mite.h <- decostand (mite, "hellinger")
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
mite.xy.c <- scale(mite.xy, center = TRUE, scale = FALSE)
```




```{r}
# 单变量空间相关图 - Univariate spatial correlogram (based on Moran's I)
# 绘制PCOA图, 并添加与差异阈值以下的值对应的线条
# https://github.com/JoeyBernhardt/NumericalEcology/blob/master/plot.links.R
plot.links(mite.xy, thresh = 0.7)
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/dnearneigh
# 基于欧式距离(Euclidean distance)确定邻近关系
nb1 <- dnearneigh(as.matrix(mite.xy), 0, 0.7)
summary(nb1)

# 基质密度的相关图 - Correlogram of substrate density
# sp.correlogram 空间相关图
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/sp.correlogram
subs.dens <- mite.env[ ,1]
subs.correlog <- 
  sp.correlogram(nb1, 
                 subs.dens, 
                 order = 14, 
                 method = "I", 
       zero.policy = TRUE)
print(subs.correlog, p.adj.method = "holm")
plot(subs.correlog)

# 螨虫数据集的 Mantel 相关图(correlogram)

# 首先去除物种数据; see Sect. 7.3
mite.h.det <- resid(lm(as.matrix(mite.h) ~ ., data = mite.xy))
mite.h.D1 <- dist(mite.h.det) # 计算距离矩阵
# mantel.correlog 计算多变量 Mantel 相关图
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/mantel.correlog
(mite.correlog <- 
  mantel.correlog(mite.h.D1, 
                  XY = mite.xy, 
                  nperm = 999))
summary(mite.correlog)

# 分类的数量
mite.correlog$n.class # or: mite.correlog[2]
# 断点 - Break points
mite.correlog$break.pts # or: mite.correlog[3]
# 绘制 Mantel 相关图(correlogram)
plot(mite.correlog)
```


### 7.2.6 空间相关性存在的检验: 条件(Testing for the Presence of Spatial Correlation: Conditions)

### 7.2.7 空间结构建模(Modelling Spatial Structures)


---

## 7.3 多变量趋势面分析(Multivariate Trend-Surface Analysis)

### 7.3.1 简介

### 7.3.2 趋势面分析的实际应用(In practice)



```{r}
# 简单模型 - 方形 & 定期采样表面 Simple models on a square, regularly sampled surface
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/expand.grid
# expand.grid - 从因子变量的所有组合创建数据框
xygrid <- expand.grid(1:10, 1:10)
plot(xygrid)

# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
(xygrid.c <- scale(xygrid, scale = FALSE))

X <- xygrid.c[ ,1]
Y <- xygrid.c[ ,2]
XY <- X + Y
XY2 <- X ^ 2  +  Y ^ 2
XY3 <- X ^ 2 - X * Y - Y ^ 2
XY4 <- X + Y  +  X ^ 2  +  X * Y  +  Y ^ 2
XY5 <- X ^ 3  +  Y ^ 3
XY6 <- X ^ 3  +  X ^ 2 * Y  +  X * Y ^ 2  +  Y ^ 3
XY7 <- X  +  Y  +  X ^ 2  +  X * Y  +  Y ^ 2  +  X ^ 3  
          +  X ^ 2 * Y  +  X * Y ^ 2  +  Y ^ 3
xy3deg <- cbind(X, Y, XY, XY2, XY3, XY4, XY5, XY6, XY7)

# 散点图来表示变量值
s.value(xygrid, xy3deg, symbol = "circle")
```


```{r}
## --- 对螨虫数据集进行趋势面分析 --- 
# 先前居中的X-Y坐标上 计算原始(非正交)三次多项式函数 - on the previously centred X-Y coordinates
mite.poly <- poly(as.matrix(mite.xy.c), 
                  degree = 3, 
                  raw = TRUE)
colnames(mite.poly) <- 
    c("X", "X2", "X3", "Y", "XY", "X2Y", "Y2", "XY2", "Y3")

# 对所有 9 个多项式进行冗余分析
(mite.trend.rda <- rda(mite.h ~ ., 
                       data = as.data.frame(mite.poly)))

# 计算调整的 R方
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/RsquareAdj
(R2adj.poly <- RsquareAdj(mite.trend.rda)$adj.r.squared)

# 使用 地理坐标的三项正交多项式 进行冗余分析 
# RDA using a third-degree orthogonal polynomial of the geographic coordinates
mite.poly.ortho <- poly(as.matrix(mite.xy), 
                        degree = 3)
colnames(mite.poly.ortho) <- 
    c("X", "X2", "X3", "Y", "XY", "X2Y", "Y2", "XY2", "Y3")
(mite.trend.rda.ortho <- 
  rda(mite.h ~ ., 
      data = as.data.frame(mite.poly.ortho)))
# 计算调整的 R方
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/RsquareAdj
(R2adj.poly2 <- RsquareAdj(mite.trend.rda.ortho)$adj.r.squared)

# 前向选择 - Forward selection using Blanchet et al. (2008a) 
# 双停准则 - double stopping criterion
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/forward.sel
# 在简化模型下使用置换进行多元变量数据集的正向选择
# Forward Selection With Multivariate Y Using Permutation Under Reducel Model
(mite.trend.fwd <- 
  forward.sel(mite.h, mite.poly.ortho, adjR2thresh = R2adj.poly2))

(mite.trend.rda2 <- rda(mite.h ~ ., 
          data = as.data.frame(mite.poly)[ ,mite.trend.fwd[ ,2]]))

# 全部检验
anova(mite.trend.rda2)
# 检验所有典范轴 - canonic axis
anova(mite.trend.rda2, by = "axis")

# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
mite.trend.fit <- 
  scores(mite.trend.rda2, 
         choices = 1:4, 
         display = "lc", 
         scaling = 1)
# 散点图来表示变量值
s.value(mite.xy, mite.trend.fit, symbol = "circle")
```


---

## 7.4 基于特征向量的空间变量与空间模型(Eigenvector-Based Spatial Variables and Spatial Modelling)

### 7.4.1 简介

### 7.4.2 基于距离的 Moran 特征向量图(Distance-Based Moran's Eigenvector Maps, dbMEM) 和 相邻矩阵主坐标分析(Principal Coordinates of Neighbour Matrices, PCNM)


#### 7.4.2.2 常规采样设计的 dbMEM 变量 (Regular Sampling Designs)

```{r}
# 1. 一维采样
# One-dimensional sampling: 具有100个等间距点的横断面 - transect with 100 equispaced points. 
# 相邻点之间的距离是 1. 
# dbmem() 自动计算阈值

# 生成样点带 - Generate transect points
tr100 <- 1 : 100

# 创建 dbMEM 本征函数(eigenfunctions) with Moran's I 对应空间正相关(positive spatial correlation): 
# 参数MEM.autocor = "positive" 默认
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/dbmem
# 空间本征函数
tr100.dbmem.tmp <- dbmem(tr100, 
                         silent = FALSE) # 是否显示计算过程
tr100.dbmem <- as.data.frame(tr100.dbmem.tmp)
# 展示特征值 - eigenvalues
attributes(tr100.dbmem.tmp)$values
# 统计正相关特征值的数量
length(attributes(tr100.dbmem.tmp)$values)

# 绘制一些 dbMEM 变量 modelling 空间正相关(positive spatial correlation) along a transect (Fig. 7.3).
par(mfrow = c(2, 4))
somedbmem <- c(1, 2, 4, 8, 15, 20, 30, 40)
for(i in 1:length(somedbmem)) {
  plot(tr100.dbmem[ ,somedbmem[i]], 
       type = "l", 
       xlab = "X coordinate", 
       ylab = c("dbMEM", somedbmem[i]))
  }

# 2. 二维采样
# Two-dimensional sampling: 等间距点的网格, 点之间的最小距离等于1
# grid of equispaced points with smallest distance between points equal to 1 (Fig. 7.4).

# 生成网格点坐标 - Generate grid point coordinates
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/expand.grid
# expand.grid - 从因子变量的所有组合创建数据框
xygrid2 <- expand.grid(1:20, 1:20)

# 创建 dbMEM 本征函数(eigenfunctions) with Moran's I 
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/dbmem
# 空间本征函数
xygrid2.dbmem.tmp <- dbmem(xygrid2)
xygrid2.dbmem <- as.data.frame(xygrid2.dbmem.tmp)
# 计数特征值数量
length(attributes(xygrid2.dbmem.tmp)$values)

somedbmem2 <- c(1, 2, 5, 10, 20, 40, 80, 120, 189)
# 散点图来表示变量值
s.value(xygrid2, xygrid2.dbmem[ ,somedbmem2], 
  method = "color", 
  symbol = "circle", 
  ppoints.cex = 0.5
  )
```


#### 7.4.2.3 甲螨数据集的基于距离的 Moran 特征向量图分析(Distance-Based Moran's Eigenvector Maps, dbMEM)

```{r}
# 螨虫数据集是否具有线性相关趋势? 
anova(rda(mite.h, mite.xy))  # Result: significant trend
# 线性去除螨虫数据 - linearly detrended mite data
# 计算残差
mite.h.det <- resid(lm(as.matrix(mite.h) ~ ., data = mite.xy))

## 第一步. 
# 构建 dbMEN 变量矩阵
# 创建 dbMEM 本征函数(eigenfunctions) with Moran's I 对应空间正相关(positive spatial correlation): 
# 参数MEM.autocor = "positive" 默认
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/dbmem
# 空间本征函数
mite.dbmem.tmp <- dbmem(mite.xy, 
                        silent = FALSE) # 不显示计算过程
mite.dbmem <- as.data.frame(mite.dbmem.tmp)
# 使用上面的截断距离 - Truncation distance used above:
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/give.thresh
# 基于距离矩阵计算最小生成树的最大距离
(thr <- give.thresh(dist(mite.xy)))

# 统计特征值
attributes(mite.dbmem.tmp)$values
length(attributes(mite.dbmem.tmp)$values)

## 第二步. 
# 对'去势 - detrended'已数据变换(Hellinger-transformed)的螨虫数据集进行全局 dbMEN 分析
(mite.dbmem.rda <- rda(mite.h.det ~ ., mite.dbmem))
anova(mite.dbmem.rda)

## 第三步. 
# 因为 R-square 是显著性的, 因此计算调整后的 R2 并对dbMEN 变量进行正向选择
(mite.R2a <- RsquareAdj(mite.dbmem.rda)$adj.r.squared)
(mite.dbmem.fwd <- forward.sel(mite.h.det, as.matrix(mite.dbmem), 
  adjR2thresh = mite.R2a))
(nb.sig.dbmem <- nrow(mite.dbmem.fwd)) # 显著的数量
# 按照升序筛选显著性
(dbmem.sign <- sort(mite.dbmem.fwd[ ,2]))
# 将显著性的 dbMEN 存入新对象
dbmem.red <- mite.dbmem[ ,c(dbmem.sign)]

## 第四步. 
# 对 8 个显著性的 dbMEN 变量进行 dbMEN 分析
# 正向选择之后的调整的 R方: R2adj = 0.2418
(mite.dbmem.rda2 <- rda(mite.h.det ~ ., data = dbmem.red))
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/RsquareAdj
(mite.fwd.R2a <- RsquareAdj(mite.dbmem.rda2)$adj.r.squared)
anova(mite.dbmem.rda2)
(axes.test <- anova(mite.dbmem.rda2, by = "axis"))
# 显著性轴的数量
(nb.ax <- length(which(axes.test[ ,ncol(axes.test)] <=  0.05)))

## 第五步. 
# 绘制显著性的典范轴 - canonical axes
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
mite.rda2.axes <- 
  scores(mite.dbmem.rda2, 
         choices = c(1:nb.ax), 
         display = "lc", 
         scaling = 1)
 
par(mfrow = c(1,nb.ax))
# sr.value() 为自备函数
for(i in 1:nb.ax) {
    sr.value(mite.xy, mite.rda2.axes[ ,i], 
             sub = paste("RDA",i), 
             csub = 2)
  }
```




```{r}
# 解释空间变化: 
# 使用Shapiro-Wilk残差正态性检验 - 对环境变量的显著性的典范轴进行回归
mite.rda2.axis1.env <- lm(mite.rda2.axes[ ,1] ~ ., data = mite.env)
# resid 计算残差
# https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/shapiro.test
# Shapiro-Wilk Normality Test - 正态性检验
shapiro.test(resid(mite.rda2.axis1.env))
summary(mite.rda2.axis1.env)

mite.rda2.axis2.env <- lm(mite.rda2.axes[ ,2] ~ ., data = mite.env)
# resid 计算残差
# https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/shapiro.test
# Shapiro-Wilk Normality Test - 正态性检验
shapiro.test(resid(mite.rda2.axis2.env))
summary(mite.rda2.axis2.env)

# 根据置换的 p-value, 第三轴可能不重要. 
# 在本示例中, 以下 3 行可能会报错
mite.rda2.axis3.env <- lm(mite.rda2.axes[ ,2] ~ ., data = mite.env)
# resid 计算残差
# https://www.rdocumentation.org/packages/stats/versions/3.5.2/topics/shapiro.test
# Shapiro-Wilk Normality Test - 正态性检验
shapiro.test(resid(mite.rda2.axis3.env))
summary(mite.rda2.axis3.env)

# 绘制由所有 dbMEM 本征函数解释的 方差的尺度图 - Scalogram 
# scalog() 自备函数
scalog(mite.dbmem.rda)

# 绘制 8 个显著性的 dbMEN 变量的地图
# 使用自备函数 sr.value()
par(mfrow = c(2, 4))
for(i in 1 : ncol(dbmem.red)) {
    sr.value(mite.xy, 
             dbmem.red[ ,i], 
             # sub = paste("dbMEM",i), 
             sub = paste("dbMEM",dbmem.sign[i]), 
             csub = 2)
  }
# 散点图来表示变量值
s.value(mite.xy, dbmem.red)
```



```{r}
## 对螨虫数据集的 dbMEN 分析 - 大规模 broad scale
(mite.dbmem.broad <- 
  rda(mite.h.det ~ ., data = mite.dbmem[ ,c(1,3,4)]))
anova(mite.dbmem.broad)
(axes.broad <- anova(mite.dbmem.broad, by = "axis"))
# 显著性轴的数量
(nb.ax.broad <- 
  length(which(axes.broad[ , ncol(axes.broad)] <=  0.05)))

# 绘制显著性的典范轴 - canonical axes
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
mite.dbmembroad.axes <- 
  scores(mite.dbmem.broad, 
         choices = c(1,2), 
         display = "lc", 
         scaling = 1)

par(mfrow = c(1, 2))
# 使用自备函数 sr.value() - 绘图
sr.value(mite.xy, mite.dbmembroad.axes[ ,1])
sr.value(mite.xy, mite.dbmembroad.axes[ ,2])

# 解释广义的空间变化 - broad-scaled spatial variation: 两个显著性的空间典范轴(spatial canonical axes)对环境变量的回归
mite.dbmembroad.ax1.env <-   lm(mite.dbmembroad.axes[ ,1] ~ ., data = mite.env)
summary(mite.dbmembroad.ax1.env)
mite.dbmembroad.ax2.env <-  lm(mite.dbmembroad.axes[ ,2] ~ ., data = mite.env)
summary(mite.dbmembroad.ax2.env)

## 对螨虫数据集的 dbMEN 分析 - 中等规模 medium scale
(mite.dbmem.med <-  rda(mite.h.det ~ ., data = mite.dbmem[ ,c(6,7,10,11)]))
anova(mite.dbmem.med)
(axes.med <- anova(mite.dbmem.med, by = "axis"))
# 统计显著性轴的数量
(nb.ax.med <- length(which(axes.med[ ,ncol(axes.med)] <=  0.05)))

# 绘制显著性的典范轴 - canonical axes
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
mite.dbmemmed.axes <-  
  scores(mite.dbmem.med, 
         choices = c(1,2), 
         display = "lc", 
         scaling = 1)
 
par(mfrow = c(1, 2))
# 使用自备函数 sr.value() - 绘图
sr.value(mite.xy, mite.dbmemmed.axes[ ,1])
sr.value(mite.xy, mite.dbmemmed.axes[ ,2])

# 解释中等尺度的空间变化：两个显著性的空间规范轴对环境变量的回归Interpreting the medium-scaled spatial variation: regression of the two significant spatial canonical axes on the environmental variables
mite.dbmemmed.ax1.env <-  lm(mite.dbmemmed.axes[ ,1] ~ ., data = mite.env)
summary(mite.dbmemmed.ax1.env)
mite.dbmemmed.ax2.env <-   lm(mite.dbmemmed.axes[ ,2] ~ ., data = mite.env)
summary(mite.dbmemmed.ax2.env)

## 对螨虫数据集的 dbMEN 分析 - 精细规模 fine scale
(mite.dbmem.fine <-  rda(mite.h.det ~ ., data = as.data.frame(mite.dbmem[ ,20])))
anova(mite.dbmem.fine)
#>>> 分析就此停止, 冗余分析的结果没有显著性
```


#### 7.4.2.4 Hassle-Free dbMEM Analysis: 函数 quickMEM()

```{r}
mite.dbmem.quick <- quickMEM(mite.h, mite.xy)
summary(mite.dbmem.quick)
# 特征值
mite.dbmem.quick[[2]]  # OR mite.dbmem.quick$eigenvalues
# 前向选择的结果
mite.dbmem.quick[[3]]  # OR mite.dbmem.quick$fwd.sel

plot(mite.dbmem.quick$RDA, scaling = 2)
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
sp.scores2 <- 
  scores(mite.dbmem.quick$RDA, 
         choices = 1:2, 
         scaling = 2, 
         display = "sp")
arrows(0, 0, 
  sp.scores2[ ,1] * 0.9, 
  sp.scores2[ ,2] * 0.9, 
  length = 0, 
  lty = 1, 
  col = "red")
```



#### 7.4.2.5 结合基于距离的 Moran 特征向量图分析 & 方差分解(Variation Partitioning)


```{r}
# 1. 检验趋势 - Test trend
mite.XY.rda <- rda(mite.h, mite.xy)
anova(mite.XY.rda)

# 2. 检验环境变量的前向选择 - Test and forward selection of the environmental variables
# 将环境变量3到5重新编码为虚拟二进制变量
# https://www.rdocumentation.org/packages/stats/versions/3.6.0/topics/model.matrix
substrate <- model.matrix( ~ mite.env[ ,3])[ ,-1]
shrubs <- model.matrix( ~ mite.env[ ,4])[ ,-1]
topography <- model.matrix( ~ mite.env[ ,5])[ ,-1]
mite.env2 <- cbind(mite.env[ ,1:2], substrate, shrubs, topography)
colnames(mite.env2) <- 
  c("SubsDens", "WatrCont", "Interface", "Litter", "Sphagn1",
    "Sphagn2", "Sphagn3", "Sphagn4", "Shrubs_Many", "Shrubs_None", 
    "topography")
# 环境变量的前向选择
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/cca
mite.env.rda <- rda(mite.h ~., mite.env2)
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/RsquareAdj
(mite.env.R2a <- RsquareAdj(mite.env.rda)$adj.r.squared)
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/forward.sel
# 在缩减模式(reduced model)下通过残差的置换进行前向选择
mite.env.fwd <- 
  forward.sel(mite.h, mite.env2,
              adjR2thresh = mite.env.R2a, 
              nperm = 9999)
env.sign <- sort(mite.env.fwd$order)
env.red <- mite.env2[ ,c(env.sign)]
colnames(env.red)

# 3. dbMEN 变量的检验和前向选择
# 对'去势'后的螨虫数据集进行全局 dbMEN 分析
mite.det.dbmem.rda <- rda(mite.h.det ~., mite.dbmem)
anova(mite.det.dbmem.rda)
# 因为分析结果呈现显著性, 所以计算调整后的R方并进行 dbMEN 变量的前向选择
(mite.det.dbmem.R2a <- 
  RsquareAdj(mite.det.dbmem.rda)$adj.r.squared)
(mite.det.dbmem.fwd <- 
  forward.sel(mite.h.det, 
              as.matrix(mite.dbmem), 
    adjR2thresh = mite.det.dbmem.R2a))
# 统计显著的 dbMEN 数量
(nb.sig.dbmem <- nrow(mite.det.dbmem.fwd))
# 升序筛选并识别显著的 dbMEN 结果
(dbmem.sign <- sort(mite.det.dbmem.fwd$order))
# 存储显著性结果
dbmem.red <- mite.dbmem[ ,c(dbmem.sign)]

# 4. 任意(Arbitrarily)将显著性的 dbMEM 划分为广泛和精细的规模
# 大规模 - Broad scale: dbMEM 1, 3, 4, 6, 7
dbmem.broad <- dbmem.red[ , 1 : 5]
# 精细规模 - Fine scale: dbMEM 10, 11, 20
dbmem.fine <- dbmem.red[ , 6 : 8]

## 5. Mite - environment - trend - dbMEM  方差分解(variation partitioning)
# varpart() 方差分解
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/varpart
(mite.varpart <- 
  varpart(mite.h, env.red, mite.xy, dbmem.broad, dbmem.fine))

# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/varpart
# par(mfrow = c(1,2))
showvarparts(4, bg = c("red", "blue", "yellow", "green"))
plot(mite.varpart, 
     digits = 2, 
     bg = c("red", "blue", "yellow", "green")
     ) 
```


```{r}
# 检测独特分数(unique fractions) [a], [b], [c], [d]
# Fraction [a], pure environmental
anova(
  rda(mite.h, env.red, cbind(mite.xy, dbmem.broad, dbmem.fine))
  )
# Fraction [b], pure trend
anova(
  rda(mite.h, mite.xy, cbind(env.red, dbmem.broad, dbmem.fine))
  )
# Fraction [c], pure broad scale spatial
anova(rda
  (mite.h, dbmem.broad, cbind(env.red, mite.xy, dbmem.fine))
  )
# Fraction [d], pure fine scale spatial
anova(
  rda(mite.h, dbmem.fine, cbind(env.red, mite.xy, dbmem.broad))
  )
```



### 7.4.3 更广泛背景下的Moran 特征向量图分析方法(MEM): 地理距离以外的权重(Weights Other than Geographic Distances)


#### 7.4.3.1 简介


#### 7.4.3.2 甲螨数据集的广义 MEM 分析 ( Moran 特征向量图 )

```{r}
## '去势'螨虫数据集的 Moran 特征向量图分析(MEM)

# 选择最优空间加权矩阵 - Selection of an optimal spatial weighting matrix

# 1. Search based on Delaunay triangulation.
# http://mathworld.wolfram.com/DelaunayTriangulation.html
# https://en.wikipedia.org/wiki/Delaunay_triangulation
# 将 mite.h.det 作为响应数据, 将 mite.del 作为 Delaunay triangulation 数据
# 非加权矩阵(binary weights only): 
# 1 - 易于沟通 means connected (easy communication), 
# 0 - 不可沟通 - not connected (无交流的可能 - no exchange  possible). 
# 函数 test.W() 选择 Moran 特征向量图分析中的变量, 构建 Delaunay triangulation 分析的基础

# Delaunay triangulation 数据集 & 模型选择
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/tri2nb
# 三个对象的邻近列表
# 将二维坐标矩阵转换为类 'nb' 的邻近列表
(mite.del <- tri2nb(mite.xy)) 
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/test.W
# test.W - 计算和测试空间加权矩阵特征向量的函数
mite.del.res <- 
  test.W(mite.h.det, 
         mite.del, 
         MEM.autocor = "positive")
# 汇总最优模型的结果
summary(mite.del.res$best)
# 未调整的 R方 - with the smallest AICc value
(R2.del <- 
  mite.del.res$best$AIC$R2[which.min(mite.del.res$best$AIC$AICc)])
# 调整的 R方 - with the smallest AICc value
# https://www.rdocumentation.org/search?q=RsquareAdj&latest=
RsquareAdj(
  R2.del, 
  n = nrow(mite.h.det), 
  m = which.min(mite.del.res$best$AIC$AICc)
  )

# 2. 通过距离对 Delaunay triangulation 进行加权.
# 距离最大值是 1, 提升效力至 - y. 
# 进行数据转换之后, 接近 1 的表示易于交换(通信), 接近 0 的表示难于通信交流.
f2 <- function(D, dmax, y) { 
  1 - (D/dmax)^y 
  }

# 获取链接中最大的欧式距离(Euclidean distance)
# 该链接属于 Delaunay triangulation
max.d1 <- max(unlist(nbdists(mite.del, as.matrix(mite.xy)))) 
# 效力 - Power y 设置的范围 2 ~ 10
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/test.W
# test.W - 计算和测试空间加权矩阵特征向量的函数
mite.del.f2 <- 
  test.W(mite.h.det, mite.del, 
         MEM.autocor = "positive", 
         f = f2, 
         y = 2:10, 
         dmax = max.d1, 
         xy = as.matrix(mite.xy))
# 最优模型的未调整 R方
(R2.delW <- 
  mite.del.f2$best$AIC$R2[which.min(mite.del.f2$best$AIC$AICc)])
# 最优模型的调整的R方
# https://www.rdocumentation.org/search?q=RsquareAdj&latest=
RsquareAdj(
  R2.delW, 
  n = nrow(mite.h.det), 
  m = which.min(mite.del.f2$best$AIC$AICc)
  )

# 3a. 基于距离连接矩阵（点周围半径）
# Connectivity matrix based on a distance (radius around points)
# 基于去趋势螨数据的多变量变异函数评估相关距离，具有20个距离等级
# variogmultiv() - 计算多元经验变异函数
# https://www.rdocumentation.org/packages/adespatial/versions/0.0-4/topics/variogmultiv
(mite.vario <- variogmultiv(mite.h.det, 
                            mite.xy, 
                            nclass = 20))# 距离类别数
plot(
  mite.vario$d, 
  mite.vario$var, 
  ty = 'b', 
  pch = 20, 
  xlab = "Distance", 
  ylab = "C(distance)"
  )
# 构建 10 个邻近矩阵 (class nb) 
# 10 个阈值距离的向量
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/give.thresh
# give.thresh - 基于距离矩阵计算最小生成树的最大距离
(thresh10 <- seq(give.thresh(dist(mite.xy)), 4, le = 10))
# 创建 10 个邻近矩阵
# 每个矩阵包含长度小于或等于阈值的所有连接
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/lapply
list10nb <- 
  lapply(thresh10, # 在列表或向量上应用函数
         dnearneigh, 
         x = as.matrix(mite.xy), 
         d1 = 0)
# 显示第一个邻域矩阵的'摘录'(excerpt )
# nb2listw & listw2mat - 该函数为具有所选编码方案的空间权重的邻近列表生成权重矩阵
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2mat
print(
  listw2mat(nb2listw(list10nb[[1]], style = "B"))[1:10,1:10], 
  digits = 1
  )
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/test.W
# test.W - 计算和测试空间加权矩阵特征向量的函数
# 连接没有权重信息
mite.thresh.res <- 
  lapply(list10nb, # 返回的是一个列表
    function(x) test.W(x, 
                       Y = mite.h.det, 
                       MEM.autocor = "positive")
    )
# Lowest AICc, best model, threshold distance of 最优模型
mite.thresh.minAIC <- 
  sapply(mite.thresh.res, # 返回的是一个向量或者矩阵
         function(x) min(x$best$AIC$AICc, 
                         na.rm = TRUE))
# Smallest AICc (best model among the 10)
min(mite.thresh.minAIC)
# Number of the model among the 10
which.min(mite.thresh.minAIC)
# 截断阈值(距离) - Truncation threshold (distance)
thresh10[which.min(mite.thresh.minAIC)]

# 3b. 分析操作的另一种操作: 通过距离的幂的补充加权的连接, 1-(d/dmax)^y. 
# 进行数据转换之后, 接近 1 的表示易于交换(通信), 接近 0 的表示难于通信交流.
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/test.W
# test.W - 计算和测试空间加权矩阵特征向量的函数
# nbdists - 空间连接距离测度 - Spatial Link Distance Measures
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nbdists
mite.thresh.f2 <- 
  lapply(list10nb, # 返回一个列表
         function(x) test.W(x, Y = mite.h.det, 
         MEM.autocor = "positive", 
         f = f2, 
         y = 2:10, 
         dmax = max(unlist(nbdists(x, as.matrix(mite.xy)))), 
         xy = as.matrix(mite.xy)))
# Lowest AIC, best model
mite.f2.minAIC <- 
  sapply(mite.thresh.f2,  # 返回的是一个向量或者矩阵
         function(x) min(x$best$AIC$AICc, na.rm = TRUE))
# Smallest AICc (best model among the 10)
min(mite.f2.minAIC)
# Number of the model among the 10
(nb.bestmod <- which.min(mite.f2.minAIC))
# Actual dmax of best model
(dmax.best <- mite.thresh.f2[nb.bestmod][[1]]$all[1,2])

# 提取 MEN 模型信息 - Moran 特征向量图分析
mite.MEM.champ <- 
  unlist(mite.thresh.f2[which.min(mite.f2.minAIC)], 
         recursive = FALSE)
summary(mite.MEM.champ)
# Number of MEM variables in best model
(nvars.best <- which.min(mite.MEM.champ$best$AIC$AICc))
mite.MEM.champ$best$AIC$ord
# 选择最优模型中的 MEM (Moran 特征向量图分析) 变量
MEMid <- mite.MEM.champ$best$AIC$ord[1:nvars.best]
sort(MEMid)
MEM.all <- mite.MEM.champ$best$MEM
MEM.select <- mite.MEM.champ$best$MEM[ , sort(c(MEMid))]
colnames(MEM.select) <- sort(MEMid)
# 最优模型的未调整的 R方
R2.MEMbest <- mite.MEM.champ$best$AIC$R2[nvars.best]
# 最优模型的调整的 R方
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/RsquareAdj
RsquareAdj(R2.MEMbest, nrow(mite.h.det), length(MEMid))
# plot.links() 自备函数, 可绘制连接
plot.links(mite.xy, thresh = dmax.best)

# 约束性的冗余分析
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/cca
(mite.MEM.rda <- rda(mite.h.det~., as.data.frame(MEM.select)))
(mite.MEM.R2a <- RsquareAdj(mite.MEM.rda)$adj.r.squared)
anova(mite.MEM.rda)
(axes.MEM.test <- anova(mite.MEM.rda, by = "axis"))
# 显著性轴的数量
(nb.ax <- 
  length(which(axes.MEM.test[ ,ncol(axes.MEM.test)] <=  0.05)))

# 绘制显著性的典范轴 - canonical axis
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
mite.MEM.axes <- 
  scores(mite.MEM.rda, 
         choices = 1:nb.ax, 
         display = "lc", 
         scaling = 1)

if(nb.ax <=  2) {
  par(mfrow = c(1,2))
  } else { 
  par(mfrow = c(2,2))
  } 

for(i in 1:ncol(mite.MEM.axes)) {
  sr.value(mite.xy, mite.MEM.axes[ ,i])
  }

# 绘制显著性的 MEM 变量(Moran 特征向量图分析)
if(ncol(MEM.select) <=  6) {
  par(mfrow = c(2,3))
  }  else  {
    par(mfrow = c(3,3)) 
  }

for(i in 1:ncol(MEM.select)) {
 sr.value(mite.xy, 
          MEM.select[ ,i], 
          sub = sort(MEMid)[i], 
          csub = 2)
  }
# 计算 the retained MEM & dbMEM variables 之间的相关性
cor(MEM.select, dbmem.red) # 计算相关关系 & 方差 & 协方差
```


#### 7.4.3.3 其他类型的连通矩阵 


```{r}
# 连通性递减顺序的连接矩阵的示例
# 所有这些邻域矩阵都存储在 objects of class nb Delaunay triangulation (如前文示例所述)
mite.del <- tri2nb(mite.xy) 
# Gabriel graph
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/graphneigh
# graph2nb - 基于图的空间权重
mite.gab <- graph2nb(gabrielneigh(as.matrix(mite.xy)), sym = TRUE)
# Relative neighbourhood
mite.rel <- graph2nb(relativeneigh(as.matrix(mite.xy)), sym = TRUE)
# Minimum spanning tree
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/mst.nb
# mst.nb - 基于最小生成树计算邻域的函数
mite.mst <- mst.nb(dist(mite.xy))

# 绘制连通矩阵
# par(mfrow = c(2,2))
plot(mite.del, mite.xy, col = "red", pch = 20, cex = 1)
title(main = "Delaunay triangulation ")
plot(mite.gab, mite.xy, col = "purple", pch = 20, cex = 1)
title(main = "Gabriel graph")
plot(mite.rel, mite.xy, col = "dark green", pch = 20, cex = 1)
title(main = "Relative neighbourhood")
plot(mite.mst, mite.xy, col = "brown", pch = 20, cex = 1)
title(main = "Minimum spanning tree")


# 编辑连接
# 1. 交互 - Interactive:
plot(mite.del, mite.xy, col = "red", pch = 20, cex = 2)
title(main = "Delaunay triangulation")
# 交互性删除
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/edit.nb
# 邻近列表的交互式编辑
mite.del2 <- edit.nb(mite.del, mite.xy)

# 2. 也可以通过命令行进行删改 
# nb2mat - 邻近列表的空间权重矩阵
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2mat
mite.del.mat <- nb2mat(mite.del, style = "B")
# 移除连接关系
mite.del.mat[23,35] <- 0
mite.del.mat[35,23] <- 0
# 数据类型的反向转换 Back-conversion
# neig - 邻域图
# https://www.rdocumentation.org/packages/ade4/versions/1.7-13/topics/neig
mite.del3 <- neig2nb(neig(mat01 = mite.del.mat))
 
plot(mite.del3, mite.xy)

# Delaunay triangulation: 数据的核心邻近的列表 ?
mite.del[[23]]      # 编辑之前
mite.del2[[23]]     # 交互编辑之后
mite.del3[[23]]     # 命令行编辑之后


# 基于距离的连通矩阵(点周围半径)
# 使用相同的截断距离(truncation distance) dmin 作为 dbMEM 示例 (1.011187).
dmin = 1.011187
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/dnearneigh
# Neighbourhood Contiguity By Distance - 邻里邻接距离
mite.thresh4 <- dnearneigh(as.matrix(mite.xy), 0, dmin * 4)
# Display some values
# Spatial Weights Matrices For Neighbours Lists - 邻近列表的空间权重矩阵
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2mat
nb2mat(mite.thresh4)[1:10,1:10]

# 使用更短的距离 (1 * dmin, 2 * dmin)
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/dnearneigh
# Neighbourhood Contiguity By Distance - 邻里邻接距离
mite.thresh1 <- dnearneigh(as.matrix(mite.xy), 0, dmin * 1)
mite.thresh2 <- dnearneigh(as.matrix(mite.xy), 0, dmin * 2)
# 使用长一点的距离
mite.thresh8 <- dnearneigh(as.matrix(mite.xy), 0, dmin * 8)

# par(mfrow = c(1,2))
plot(mite.thresh1, mite.xy, col = "red", pch = 20, cex = 0.8)
title(main = "1 * dmin")
plot(mite.thresh4, mite.xy, col = "red", pch = 20, cex = 0.8)
title(main = "4 * dmin")

# 对象之间的转换 - a "nb" object into a "listw" object
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2listw
# nb2listw - 邻近列表的空间权重
mite.thresh4.lw <- nb2listw(mite.thresh4, style = "B")
# listw2mat - 邻近列表的空间权重
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2mat
print(listw2mat(mite.thresh4.lw)[1:10,1:10], digits = 1)

# Creation of a spatial weighting matrix W = Hadamard product of  B and A.
# Replace "1" by Euclidean distances in the connectivity matrix
mite.thresh4.d1 <- nbdists(mite.thresh4, as.matrix(mite.xy))
# Weights as function of inverse distance
mite.inv.dist <- 
  lapply(mite.thresh4.d1, # 
         function(x) 1-x/max(dist(mite.xy))
        )
# Creation of spatial weighting matrix W. Argument "B" stands for "binary" but concerns the links themselves, not their weights
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2listw
# nb2listw - 邻近列表的空间权重
mite.invdist.lw <- 
  nb2listw(mite.thresh4, 
           glist = mite.inv.dist, 
           style = "B")
# listw2mat - 邻近列表的空间权重
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/nb2mat
print(listw2mat(mite.invdist.lw)[1:10,1:10], digits = 2)

# 计算 Moran 特征向量图分析的向量 (from an object of class listw)
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/scores.listw
# scores.listw - Compute And Manage Moran's Eigenvector Maps (MEM)
mite.invdist.MEM <- scores.listw(mite.invdist.lw)
summary(mite.invdist.MEM)
attributes(mite.invdist.MEM)$values
 
barplot(attributes(mite.invdist.MEM)$values)

# Store all MEM vectors in new object
mite.invdist.MEM.vec <- as.matrix(mite.invdist.MEM)

# Test of Moran's I of each eigenvector - 特征向量
mite.MEM.Moran <- 
  moran.randtest(mite.invdist.MEM.vec, 
                 mite.invdist.lw, 
                 999)

# MEM with significant spatial correlation
which(mite.MEM.Moran$pvalue <=  0.05)
length(which(mite.MEM.Moran$pvalue <=  0.05))

# MEM with 正空间相关
MEM.Moran.pos <- 
  which(mite.MEM.Moran$obs > -1/(nrow(mite.invdist.MEM.vec)-1))
mite.invdist.MEM.pos <- mite.invdist.MEM.vec[ ,MEM.Moran.pos]
# MEM with positive *and significant* spatial correlation - 两种筛选标准
mite.invdist.MEM.pos.sig <- 
  mite.invdist.MEM.pos[ ,which(mite.MEM.Moran$pvalue <=  0.05)]
# 绘制类型 - I 的数据信息
plot(attributes(mite.invdist.MEM)$values, 
     mite.MEM.Moran$obs, 
     ylab = "Moran's I", 
     xlab = "Eigenvalues"
     )
text(0, 
     0.55, 
     paste("Correlation = ", 
           cor(mite.MEM.Moran$obs, attributes(mite.invdist.MEM)$values)
           )
     )
```


### 7.4.4 如何选择应用正空间相关的 MEM 或者负空间相关的 MEM 

### 7.4.5 非对称的特征向量图(Asymmetric Eigenvector Maps, AEM): 方向性很重要时(When Directionality Matters)

#### 7.4.5.1 简介

#### 7.4.5.2 非对称的特征向量图(Asymmetric Eigenvector Maps, AEM)分析方法的原理与应用


```{r}
# 编码 - 河流 arborescence 数据集; See Legendre and Legendre (2012, p. 889).
node1 <- c(1, 0, 0, 0, 0, 0, 0, 0)
n2lk6 <- c(0, 1, 0, 0, 0, 0, 0, 0)
n3lk3 <- c(1, 0, 1, 0, 0, 0, 0, 0)
n4lk2 <- c(1, 0, 0, 1, 0, 0, 0, 0)
node5 <- c(0, 1, 0, 0, 1, 0, 0, 0)
n6lk1 <- c(1, 0, 0, 1, 0, 1, 0, 0)
ln7k4 <- c(0, 1, 0, 0, 1, 0, 1, 0)
n8lk5 <- c(0, 1, 0, 0, 1, 0, 0, 1)
arbor <- rbind(node1, n2lk6, n3lk3, n4lk2, node5, 
               n6lk1, ln7k4, n8lk5)

# 构建非对称的特征向量图(Asymmetric Eigenvector Maps, AEM)
(arbor.aem <- aem(binary.mat = arbor))
arbor.aem.vec <- arbor.aem$vectors

# AEM特征函数也可以通过奇异值分解(svd())直接获得, 这是函数aem（）所做的:
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
arbor.c <- scale(arbor, 
                 center = TRUE, 
                 scale = FALSE)
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/svd
# svd() - 矩阵的奇异值分解 - Singular Value Decomposition Of A Matrix
arbor.svd <- svd(arbor.c)
# 奇异值 of the construction above
arbor.svd$d[1:7]
# AEM 本征函数 eigenfunctions of the construction above
arbor.svd$u[ ,1:7]

# ---->>>在本书中绘制===========
# 非对称的特征向量图(Asymmetric Eigenvector Maps, AEM)
# 图中位点的坐标
xx <- c(2.75, 2, 3.5, 1, 2, 3.5, 2, 3, 4)
yy <- c(1,2,2,3,3,3,4,4,4)
data.xy <- data.frame(xx,yy)
rownames(data.xy) <-
  c("N0", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8")
arbor.points <- 
  rbind(rep(0,7), arbor.svd$u[ ,1:7]) # With node 0 added
# 改变显著值 of AEM 5
arbor.points[ ,5] <- -arbor.points[ ,5]
par(mfrow = c(3,3))
for(i in 1:7) {
  sr.value(data.xy, 
         arbor.points[ ,i], 
         method = "greylevel", 
         csize = 1, 
         clegend = 0, 
         grid = FALSE, 
         include.origin = FALSE, 
         addaxes = FALSE, 
         sub = paste("AEM",i), 
         csub = 2)
  }
# <<<--- 本书中的相关章节结束 ===========
```


```{r}
# 采样设计编码：10个跨河断面，每个断面4个陷阱。 边缘加权与反平方距离成比例。
# X-Y coordinates
# # 生成网格点坐标 - Generate grid point coordinates
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/expand.grid
# expand.grid - 从因子变量的所有组合创建数据框
xy <- cbind(1:40, expand.grid(1:4, 1:10))
# Object of class nb (spdep) containing links of chess type "queen"
# https://www.rdocumentation.org/packages/spdep/versions/1.1-2/topics/cell2nb
# cell2nb - 生成网格单元的邻近列表
nb <- cell2nb(4, 10, "queen")
# Site-by-edges matrix  (produces a fictitious object "0") with automatic plot of the site-by-edges matrix
# aem.build.binary - 构建Site-by-edges二进制矩阵
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/aem.build.binary
edge.mat <- aem.build.binary(nb, xy)
D1.mat <- as.matrix(dist(xy)) # 欧式距离 Euclidean distances
# Extract the edges, remove the ones directly linked to site 0
edges.b <- edge.mat$edges[-1:-4,]
# 创建向量
length.edge <- vector(length = nrow(edges.b))
for(i in 1:nrow(edges.b)) {
  length.edge[i] <- D1.mat[edges.b[i,1], edges.b[i,2]]
  }
# Weighting of edges based on inverse squared distance
# 基于反平方距离的边的加权
weight.vec <- 1-(length.edge/max(length.edge))^2
# 构造 AEM 特征函数 from edge.mat, of class build.binary
# 非对称的特征向量图(Asymmetric Eigenvector Maps, AEM)
example.AEM <- 
  aem(aem.build.binary = edge.mat, 
      weight = weight.vec, 
      rm.link0 = TRUE)

example.AEM$values
ex.AEM.vec <- example.AEM$vectors
# 创建 5 个虚拟物种
# 两个随机分布的物种
# trunc - 模拟截断分布
sp12 <- matrix(trunc(rnorm(80,5,2),0),40)
# 一种物种仅限于溪流的上半部分
sp3 <- c(trunc(rnorm(20,8,2.5),0), rep(0,20))
# 一个物种仅限于横断面的左半部分
sp4 <- t(matrix(c(trunc(rnorm(20,8,3),0), rep(0,20)),10))
sp4 <- as.vector(sp4)
# 一种物种仅限于4个左上部位
sp5 <- c(4,7,0,0,3,8, rep(0,34))
# 创建物种矩阵
sp <- cbind(sp12, sp3, sp4, sp5)
colnames(sp) <- c("sp1", "sp2", "sp3", "sp4", "sp5")

# Global AEM analysis with 20 first AEM variables (for computation of R2a)
# 具有20个第一个AEM变量的全局AEM分析（用于计算R2a）
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/cca
AEM.20 <- rda(sp ~ ., 
              as.data.frame(ex.AEM.vec[ ,1:20]))
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/RsquareAdj
(R2a.AEM <- RsquareAdj(AEM.20)$adj.r.squared)
# 非对称的特征向量图(Asymmetric Eigenvector Maps, AEM)变量的前向选择
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/forward.sel
# 通过简化模型下的残差置换进行前向选择
AEM.fwd <- forward.sel(sp, 
                       ex.AEM.vec)
# AEM.fwd <- forward.sel(sp, 
#                        ex.AEM.vec,
#                        adjR2thresh = R2a.AEM)
# R2a.AEM - 为负值, 运行报错; 官网给的该参数可以为负值...相互矛盾, 问题在何处?
(AEM.sign <- sort(AEM.fwd[ ,2]))
# 保存显著性的结果
AEM.sign.vec <- ex.AEM.vec[ ,c(AEM.sign)]
# RDA with signif. AEM - 冗余分析
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/cca
(sp.AEMsign.rda <- rda(sp ~ ., 
                       data = as.data.frame(AEM.sign.vec)))
anova(sp.AEMsign.rda)
(AEM.rda.axes.test <- anova(sp.AEMsign.rda, 
                            by = "axis"))
# 显著性轴的数量
(nb.ax.AEM <- length(which(AEM.rda.axes.test[ ,4] <=  0.05)))
# 调整的 R方
RsquareAdj(sp.AEMsign.rda)

# 绘制显著性的典范轴 - canonical axis
# 质心化 - 中心化处理矩阵(数据框)数据 - Centring
# scale() 对矩阵相似对象进行缩放或者居中
# https://www.rdocumentation.org/packages/base/versions/3.6.0/topics/scale
# 默认 center = T, 减去列平均值然后 centered
# center = F, 减去列平均值
AEM.rda.axes <- 
  scores(sp.AEMsign.rda, 
         choices = c(1,2), 
         display = "lc", 
         scaling = 1)
 
par(mfrow = c(1,nb.ax.AEM))
for(i in 1:nb.ax.AEM) sr.value(xy[ ,c(2,3)], AEM.rda.axes[ ,i])
```



---

## 7.5 另一种空间结构的观察方法: 多尺度排序(Multiscale Ordination, MSO)

### 7.5.1 多尺度排序(Multiscale Ordination, MSO)方法的基本原理

### 7.5.2 多尺度排序(Multiscale Ordination, MSO)方法在甲螨数据集探索性分析中的应用


```{r}
## 多尺度排序(Multiscale Ordination, MSO) vs 环境冗余分析 RDA -- 螨虫数据集
# https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/cca
# https://www.rdocumentation.org/packages/vegan/versions/2.4-0/topics/mso
# 执行和显示空间分割CCA或RDA结果
# Functions For Performing And Displaying A Spatial Partitioning Of Cca Or Rda Results
mite.undet.env.rda <- rda(mite.h~., mite.env2)
(mite.env.rda.mso <- 
  mso(mite.undet.env.rda, 
      mite.xy, 
      grain = dmin, 
      perm = 999))
msoplot(mite.env.rda.mso, 
        alpha = 0.05/7)

# MSO of the undetrended mite data vs environment RDA, controlling  for MEM
mite.undet.env.MEM <- 
  rda(mite.h, 
      mite.env2, 
      as.data.frame(MEM.select))
(mite.env.MEM.mso <- 
  mso(mite.undet.env.MEM, 
      mite.xy, 
      grain = dmin, 
      perm = 999))
msoplot(mite.env.MEM.mso, 
        alpha = 0.05/7) 
```


### 7.5.3 多尺度排序(Multiscale Ordination, MSO)方法在甲螨数据集和环境数据集中的应用

```{r}
# 对'去势'螨虫数据和环境数据进行多尺度排序分析(Multiscale Ordination, MSO)
# resid() - 提取模型残差
# Detrend 螨虫数据 on Y coordinate - 去势
mite.h.det2 <- resid(lm(as.matrix(mite.h) ~ mite.xy[ ,2]))
# Detrend 环境数据 on Y coordinate - 去势
env2.det <- as.data.frame(
                    resid(lm(as.matrix(mite.env2) ~ mite.xy[ ,2])))
# RDA & MSO
mitedet.envdet.rda <- rda(mite.h.det2 ~., env2.det)
(miteenvdet.rda.mso <- 
  mso(mitedet.envdet.rda, 
      mite.xy, 
      grain = dmin, 
      perm = 999))
msoplot(miteenvdet.rda.mso, alpha = 0.05/7)

# MSO of the detrended mite data vs detrended environment RDA, controlling for MEM
mite.det.env.MEM <- 
  rda(mite.h.det2, 
      env2.det, 
      as.data.frame(MEM.select))
(mite.env.MEM.mso <- 
  mso(mite.det.env.MEM, 
      mite.xy, 
      grain = dmin, 
      perm = 999))
msoplot(mite.env.MEM.mso, alpha = 0.05/7)
```


---

## 7.6 多元变量方差分析中的无重复时空交互检验(Space-Time Interaction Test in Multivariate ANOVA, Without Replicates)

### 7.6.1 简介

### 7.6.2 使用 sti() 函数进行时空交互检验



```{r}
# 导入 adespatial 包中的内置数据集 
data(trichoptera)
names(trichoptera) # 物种代码
tricho.hel <- decostand(trichoptera[ ,-c(1,2)], "hel") # 数据变换

# 时空交互分析 - sti analysis
# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/stimodels
# stimodels() - 使用无重复 ANOVA 方法进行时空交互分析 - Space-Time Interaction
stimodels(tricho.hel, 
          S = 22, # 空间点数
          Ti = 10, # 时间数量
          model = "5") # 线性时空模型

# https://www.rdocumentation.org/packages/adespatial/versions/0.3-4/topics/stimodels
# 使用 quicksti() 快速的进行时空交互分析(Space-Time Interaction Test)
quicksti(tricho.hel, 
         S = 22, # 空间点数
         Ti = 10) # 时间数量
```


---

## 7.7 结论



---

</font>
